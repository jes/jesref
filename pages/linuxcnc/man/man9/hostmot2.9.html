<!-- Creator     : groff version 1.22.4 -->
<!-- CreationDate: Thu Nov 24 19:23:47 2022 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>HOSTMOT2</title>

 <link rel="stylesheet" href="../../asciidoc.css" type="text/css" /> <link rel="stylesheet" href="../../linuxcnc.css" type="text/css" />
</head>
<body>

<h1 align="center">HOSTMOT2</h1>

<a href="#NAME">NAME</a><br>
<a href="#SYNOPSIS">SYNOPSIS</a><br>
<a href="#DESCRIPTION">DESCRIPTION</a><br>
<a href="#Board I/O Pins">Board I/O Pins</a><br>
<a href="#config modparam">config modparam</a><br>
<a href="#dpll">dpll</a><br>
<a href="#encoder">encoder</a><br>
<a href="#Synchronous Serial Interface (SSI)">Synchronous Serial Interface (SSI)</a><br>
<a href="#BiSS">BiSS</a><br>
<a href="#Fanuc encoder.">Fanuc encoder.</a><br>
<a href="#resolver">resolver</a><br>
<a href="#pwmgen">pwmgen</a><br>
<a href="#3ppwmgen">3ppwmgen</a><br>
<a href="#rcpwmgen">rcpwmgen</a><br>
<a href="#stepgen">stepgen</a><br>
<a href="#Smart Serial Interface">Smart Serial Interface</a><br>
<a href="#BSPI">BSPI</a><br>
<a href="#UART">UART</a><br>
<a href="#General Purpose I/O">General Purpose I/O</a><br>
<a href="#inm and inmux">inm and inmux</a><br>
<a href="#led">led</a><br>
<a href="#Solid State Relay">Solid State Relay</a><br>
<a href="#OutM Simple output module">OutM Simple output module</a><br>
<a href="#xy2mod">xy2mod</a><br>
<a href="#Watchdog">Watchdog</a><br>
<a href="#Raw Mode">Raw Mode</a><br>
<a href="#Setting up Smart Serial devices">Setting up Smart Serial devices</a><br>
<a href="#FUNCTIONS">FUNCTIONS</a><br>
<a href="#SEE ALSO">SEE ALSO</a><br>
<a href="#LICENSE">LICENSE</a><br>

<hr>


<h2>NAME
<a name="NAME"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">hostmot2 -
LinuxCNC HAL driver for the Mesa Electronics HostMot2
firmware.</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">See the config
modparam section below for Mesa card configuration.
Typically hostmot2 is loaded with no parameters unless
debugging is required.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="89%">


<p style="margin-top: 1em"><b>loadrt hostmot2
[debug_idrom=</b><i>N</i><b>]
[debug_module_descriptors=</b><i>N</i><b>]
[debug_pin_descriptors=</b><i>N</i><b>]
[debug_modules=</b><i>N</i><b>]</b></p> </td></tr>
</table>

<p style="margin-left:11%;"><b>debug_idrom</b> [default:
0]</p>

<p style="margin-left:22%;">Developer/debug use only!
Enable debug logging of the HostMot2 IDROM header.</p>


<p style="margin-left:11%;"><b>debug_module_descriptors</b>
[default: 0]</p>

<p style="margin-left:22%;">Developer/debug use only!
Enable debug logging of the HostMot2 Module Descriptors.</p>

<p style="margin-left:11%;"><b>debug_pin_descriptors</b>
[default: 0]</p>

<p style="margin-left:22%;">Developer/debug use only!
Enable debug logging of the HostMot2 Pin Descriptors.</p>

<p style="margin-left:11%;"><b>debug_modules</b> [default:
0]</p>

<p style="margin-left:22%;">Developer/debug use only!
Enable debug logging of the HostMot2 Modules used.</p>

<p style="margin-left:11%;"><b>use_serial_numbers</b>
[default: 0]</p>

<p style="margin-left:22%;">When creating HAL pins for
smart-serial devices name the pins by the board serial
number rather than which board and port they are connected
to. With this option set to 1 pins will have names like
<b>hm2_8i20.1234.current</b> rather than
<b>hm2_5i23.0.8i20.0.1.current</b>. The identifier consists
of the last 4 digits of the board serial number, which is
normally on a sticker on the board. This will make configs
less portable, but does mean that boards can be re-connected
less carefully.</p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">hostmot2 is a
device driver that interfaces the Mesa HostMot2 firmware to
the LinuxCNC HAL. This driver by itself does nothing, the
boards that actually run the firmware require their own
drivers before anything can happen. Currently drivers are
available for PCI, Ethernet, SPI and EPP interfaced
cards.</p>

<p style="margin-left:11%; margin-top: 1em">The HostMot2
firmware provides modules such as encoders, PWM generators,
step/dir generators, and general purpose I/O pins (GPIOs).
These things are called &quot;Modules&quot;. The firmware is
configured, at firmware compile time, to provide zero or
more instances of each of these Modules.</p>

<h2>Board I/O Pins
<a name="Board I/O Pins"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The HostMot2
firmware runs on an FPGA board. The board interfaces with
the computer via PCI, Ethernet, SPI, or EPP, and interfaces
with motion control hardware such as servos and stepper
motors via I/O pins on the board.</p>

<p style="margin-left:11%; margin-top: 1em">Each I/O pin
can be configured, at board-driver load time, to serve one
of two purposes: either as a particular I/O pin of a
particular Module instance (encoder, pwmgen, stepgen etc),
or as a general purpose digital I/O pin. By default all
Module instances are enabled, and all the board&rsquo;s pins
are used by the Module instances.</p>

<p style="margin-left:11%; margin-top: 1em">The user can
disable Module instances at board-driver load time, by
specifying a hostmot2 config string modparam. Any pins which
belong to Module instances that have been disabled
automatically become GPIOs.</p>

<p style="margin-left:11%; margin-top: 1em">All IO pins
have some HAL presence, whether they belong to an active
module instance or are full GPIOs. GPIOs can be changed (at
run-time) between inputs, normal outputs, and open drains,
and have a flexible HAL interface. IO pins that belong to
active Module instances are constrained by the requirements
of the owning Module, and have a more limited interface in
HAL. This is described in the General Purpose I/O section
below.</p>

<h2>config modparam
<a name="config modparam"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">All the
board-driver modules (hm2_pci, hm2_eth etc) accept a
load-time modparam of type string array, named
&quot;config&quot;. This array has one config string for
each board the driver should use. Each board&rsquo;s config
string is passed to and parsed by the hostmot2 driver when
the board-driver registers the board.</p>

<p style="margin-left:11%; margin-top: 1em">The config
string can contain spaces, so it is usually a good idea to
wrap the whole thing in double-quotes (the &quot;
character).</p>

<p style="margin-left:11%; margin-top: 1em">The comma
character (,) separates members of the config array from
each other.</p>

<p style="margin-left:11%; margin-top: 1em">For example, if
your control computer has one 5i20 and one 5i23 you might
load the hm2_pci driver with a HAL command (in halcmd)
something like this:</p>

<p style="margin-left:11%; margin-top: 1em"><b>loadrt
hm2_pci config=&quot;firmware=hm2/5i20/SVST8_4.BIT
num_encoders=3 num_pwmgens=3
num_stepgens=3,firmware=hm2/5i23/SVSS8_8.BIT
sserial_port_0=0000 num_encoders=4&quot;</b></p>

<p style="margin-left:11%; margin-top: 1em">Note: this
assumes that the hm2_pci driver detects the 5i20 first and
the 5i23 second. If the detection order does not match the
order of the config strings, the hostmot2 driver will refuse
to load the firmware and the board-driver (hm2_pci etc) will
fail to load. To the best of my knowledge, there is no way
to predict the order in which PCI boards will be detected by
the driver, but the detection order will be consistent as
long as PCI boards are not moved around. Best to try loading
it and see what the detection order is.</p>

<p style="margin-left:11%; margin-top: 1em">The valid
entries in the format string are:</p>


<p style="margin-left:11%; margin-top: 1em"><b>[firmware=</b><i>F</i><b>]
<br>
[num_encoders=</b><i>N</i><b>] <br>
[ssi_chan_</b><i>N</i><b>=</b><i>abc%nq</i><b>] <br>
[biss_chan_</b><i>N</i><b>=</b><i>abc%nq</i><b>] <br>
[fanuc_chan_</b><i>N</i><b>=</b><i>abc%nq</i><b>] <br>
[num_resolvers=</b><i>N</i><b>] <br>
[num_pwmgens=</b><i>N</i><b>] <br>
[num_3pwmgens=</b><i>N</i><b>] <br>
[num_rcpwmgens=</b><i>N</i><b>] <br>
[num_stepgens=</b><i>N</i><b>] <br>
[stepgen_width=</b><i>N</i><b>] <br>
[num_sserials=</b><i>N</i><b>] <br>
[sserial_port_</b><i>0</i><b>=</b><i>00000000</i><b>] <br>
[num_leds=</b><i>N</i><b>] <br>
[num_ssrs=</b><i>N</i><b>] <br>
[num_outms=</b><i>N</i><b>] <br>
[num_xy2mods=</b><i>N</i><b>] <br>
[enable_raw] <br>
firmware [</b><i>optional</i><b>]</b></p>

<p style="margin-left:22%;">Load the firmware specified by
F into the FPGA on this board. If no
&quot;<b>firmware=</b><i>F</i>&quot; string is specified,
the FPGA will not be re-programmed but may continue to run a
previously downloaded firmware.</p>

<p style="margin-left:22%; margin-top: 1em">The requested
firmware F is fetched by udev. udev searches for the
firmware in the system&rsquo;s firmware search path, usually
/lib/firmware. F typically has the form
&quot;hm2/&lt;BoardType&gt;/file.bit&quot;; a typical value
for F might be &quot;hm2/5i20/SVST8_4.BIT&quot;. The
hostmot2 firmware files are supplied by the
hostmot2-firmware packages, available from linuxcnc.org and
can normally be installed by entering the command &quot;sudo
apt-get install hostmot2-firmware-5i23&quot; to install the
support files for the 5i23 for example.</p>

<p style="margin-left:22%; margin-top: 1em">Newer FPGA
cards come pre-programmed with firmware and no
&quot;firmware=&quot; string should be used with these
cards. To change the firmware on these cards the
&quot;mesaflash&quot; utility should be used. It is
perfectly valid and reasonable to load these cards with no
config string at all.</p>

<p style="margin-left:11%;"><b>num_dplls</b> [optional,
default: -1]</p>

<p style="margin-left:22%;">The hm2dpll is a phase-locked
loop timer module which may be used to reduce sample and
write time jitter for some hm2 modules. This parameter can
be used to disable the hm2dpll by setting the number to 0.
There is only ever one module of this type, with 4 timer
channels, so the other valid numbers are -1 (enable all) and
1, both of which end up meaning the same thing.</p>

<p style="margin-left:11%;"><b>num_encoders</b> [optional,
default: -1]</p>

<p style="margin-left:22%;">Only enable the first N
encoders. If N is -1, all encoders are enabled. If N is 0,
no encoders are enabled. If N is greater than the number of
encoders available in the firmware, the board will fail to
register.</p>

<p style="margin-left:11%;"><b>ssi_chan_N</b> [optional,
default: &quot;&quot;]</p>

<p style="margin-left:22%;">Specifies how the bit stream
from a Synchronous Serial Interface device will be
interpreted. There should be an entry for each device
connected. Only channels with a format specifier will be
enabled. (as the software can not guess data rates and bit
lengths)</p>

<p style="margin-left:11%;"><b>biss_chan_N</b> [optional,
default: &quot;&quot;]</p>

<p style="margin-left:22%;">As for ssi_chan_N, but for BiSS
devices</p>

<p style="margin-left:11%;"><b>fanuc_chan_N</b> [optional,
default: &quot;&quot;]</p>

<p style="margin-left:22%;">Specifies how the bit stream
from a Fanuc absolute encoder will be interpreted. There
should be an entry for each device connected. Only channels
with a format specifier will be enabled. (as the software
can not guess data rates and bit lengths)</p>

<p style="margin-left:11%;"><b>num_resolvers</b> [optional,
default: -1]</p>

<p style="margin-left:22%;">Only enable the first N
resolvers. If N = -1 then all resolvers are enabled. This
module does not work with generic resolvers (unlike the
encoder module which works with any encoder). At the time of
writing the Hostmot2 Resolver function only works with the
Mesa 7i49 card.</p>

<p style="margin-left:11%;"><b>num_pwmgens</b> [optional,
default: -1]</p>

<p style="margin-left:22%;">Only enable the first N
pwmgens. If N is -1, all pwmgens are enabled. If N is 0, no
pwmgens are enabled. If N is greater than the number of
pwmgens available in the firmware, the board will fail to
register.</p>

<p style="margin-left:11%;"><b>num_3pwmgens</b> [optional,
default: -1]</p>

<p style="margin-left:22%;">Only enable the first N
Three-phase pwmgens. If N is -1, all 3pwmgens are enabled.
If N is 0, no pwmgens are enabled. If N is greater than the
number of pwmgens available in the firmware, the board will
fail to register.</p>

<p style="margin-left:11%;"><b>num_rcpwmgens</b> [optional,
default: -1]</p>

<p style="margin-left:22%;">Only enable the first N RC
pwmgens. If N is -1, all rcpwmgens are enabled. If N is 0,
no rcpwmgens are enabled. If N is greater than the number of
rcpwmgens available in the firmware, the board will fail to
register.</p>

<p style="margin-left:11%;"><b>num_stepgens</b> [optional,
default: -1]</p>

<p style="margin-left:22%;">Only enable the first N
stepgens. If N is -1, all stepgens are enabled. If N is 0,
no stepgens are enabled. If N is greater than the number of
stepgens available in the firmware, the board will fail to
register.</p>

<p style="margin-left:11%;"><b>num_xy2mods</b> [optional,
default: -1]</p>

<p style="margin-left:22%;">Only enable the first N
xy2mods. If N is -1, all xy2mods are enabled. If N is 0, no
xy2mods are enabled. If N is greater than the number of
xy2mods available in the firmware, the board will fail to
register.</p>


<p style="margin-left:11%; margin-top: 1em"><b>stepgen_width</b>
[optional, default: 2]</p>

<p style="margin-left:22%;">Used to mask extra, unwanted,
stepgen pins. Stepper drives typically require only two pins
(step and dir) but the Hostmot2 stepgen can drive up to 8
output pins for specialised applications (depending on
firmware). This parameter applies to all stepgen instances.
Unused, masked pins will be available as GPIO.</p>

<p style="margin-left:11%;"><b>num_sserials</b> [optional,
default: -1]</p>

<p style="margin-left:22%;">Only enable the first N of the
Smart Serial modules on the FPGA board. If N is -1, then all
Smart Serial modules will be enabled. If N=0 then no Smart
Serial modules will be enabled.</p>

<p style="margin-left:11%;"><b>sserial_port_N (N = 0 ..
3)</b> [optional, default: 00000000 for all ports]</p>

<p style="margin-left:22%;">Up to 32 Smart Serial devices
can be connected to a Mesa Anything IO board depending on
the firmware used and the number of physical connections on
the board. These are arranged in 1-4 ports of 1 to 8
channels. <br>
Some Smart Serial (SSLBP) cards offer more than one
load-time configuration, for example all inputs, or all
outputs, or offering additional analogue input on some
digital pins. <br>
To set the modes for port 0 use, for example
<b>sserial_port_0=0120xxxx</b> <br>
A &rsquo;0&rsquo;in the string sets the corresponding port
to mode 0, 1 to mode 1, and so on up to mode 9. An
&quot;x&quot; in any position disables that channel and
makes the corresponding FPGA pins available as GPIO. <br>
The string can be up to 8 characters long, and if it defines
more modes than there are channels on the port then the
extras are ignored. Channel numbering is left to right so
the example above would set sserial device 0.0 to mode 0,
0.2 to mode2 and disable channels 0.4 onwards. <br>
The sserial driver will auto-detect connected devices, no
further configuration should be needed. Unconnected channels
will default to GPIO, but the pin values will vary
semi-randomly during boot when card-detection runs, to it is
best to actively disable any channel that is to be used for
GPIO.</p>

<p style="margin-left:11%;"><b>num_bspis</b> [optional,
default: -1]</p>

<p style="margin-left:22%;">Only enable the first N
Buffered SPI drivers. If N is -1 then all the drivers are
enabled. Each BSPI driver can address 16 devices.</p>

<p style="margin-left:11%;"><b>num_leds</b> [optional,
default: -1]</p>

<p style="margin-left:22%;">Only enable the first N of the
LEDs on the FPGA board. If N is -1, then HAL pins for all
the LEDs will be created. If N=0 then no pins will be
added.</p>

<p style="margin-left:11%;"><b>num_ssrs</b> [optional,
default: -1]</p>

<p style="margin-left:22%;">Only enable the first N of the
SSR modules on the FPGA board. If N is -1, then HAL pins for
all the SSR outputs will be created. If N=0 then no pins
will be added.</p>

<p style="margin-left:11%;"><b>enable_raw</b>
[optional]</p>

<p style="margin-left:22%;">If specified, this turns on a
raw access mode, whereby a user can peek and poke the
firmware from HAL. See Raw Mode below.</p>

<h2>dpll
<a name="dpll"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The hm2dpll
module has pins like
&quot;hm2_<i>&lt;BoardType&gt;</i>.<i>&lt;BoardNum&gt;</i>.dpll&quot;
It is likely that the pin-count will decrease in the future
and that some pins will become parameters. This module is a
phase-locked loop that will synchronise itself with the
thread in which the hostmot2 &quot;read&quot; function is
installed and will trigger other functions that are
allocated to it at a specified time before or after the
&quot;read&quot; function runs. This can be applied to the
three absolute encoder types, quadrature encoder, stepgen,
and xy2mod. In the case of the absolute encoders this allows
the system to trigger a data transmission just prior to the
time when the HAL driver reads the data. In the case of
stepgens, quadrature encoders, and the xy2mod, the timers
can be used to reduce position sampling jitter. This is
especially valuable with the ethernet-interfaced cards.</p>

<p style="margin-left:11%; margin-top: 1em">Pins: <br>
(float, in)
hm2_<i>&lt;BoardType&gt;</i>.<i>&lt;BoardNum&gt;</i>.dpll.NN.timer-us</p>

<p style="margin-left:22%;">This pin sets the triggering
offset of the associated timer. There are 4 timers numbered
01 to 04, represented by the NN digits in the pin name. The
units are micro-seconds. Generally the value for reads will
be negative, and positive for writes so that input data is
sampled prior to the main hostmot read and output data is
written some time after the main hostmot2 read.</p>

<p style="margin-left:22%; margin-top: 1em">For stepgen and
quadrature encoders, the value needs to be more than the
maximum variation between read times. -100 will suffice for
most systems, and -50 will work on systems with good
performance and latency.</p>

<p style="margin-left:22%; margin-top: 1em">For serial
encoders, the value also needs to include the time it takes
to transfer the absolute encoder position. For instance, if
50 bits must be read at 500kHz then subtract an additional
50/500kHz = 100uS to get a starting value of -200.</p>

<p style="margin-left:22%; margin-top: 1em">The xy2mod uses
2 DPLL timers, one for read and one for write. The read
timer value can be the same as used by the stepgen and
quadrature encoders so the same timer channel can be shared.
The write timer is typically set to a time after the main
hostmot2 write this may take some experimentation</p>

<p style="margin-left:11%;">(float, in)
hm2_<i>&lt;BoardType&gt;</i>.<i>&lt;BoardNum&gt;</i>.dpll.base-freq-khz</p>

<p style="margin-left:22%;">This pin sets the base
frequency of the phase-locked loop. by default it will be
set to the nominal frequency of the thread in which the PLL
is running and wil not normally need to be changed.</p>

<p style="margin-left:11%;">(float, out)
hm2_<i>&lt;BoardType&gt;</i>.<i>&lt;BoardNum&gt;</i>.dpll.phase-error-us</p>

<p style="margin-left:22%;">Indicates the phase error of
the DPLL. If the number cycles by a large amount it is
likely that the PLL has failed to achieve lock and
adjustments will need to be made.</p>

<p style="margin-left:11%;">(u32, in)
hm2_<i>&lt;BoardType&gt;</i>.<i>&lt;BoardNum&gt;</i>.dpll.time-const</p>

<p style="margin-left:22%;">The filter time-constant for
the PLL. The default value is a compromise between
insensitivity to single-cycle variations and being resilient
to changes to the Linux CLOCK_MONOTONIC timescale, which can
instantly change by up to &Acirc;&plusmn;500ppm from its
nominal value, usually by timekeeping software like ntpd and
ntpdate. Default 2000 (0x7d0)</p>

<p style="margin-left:11%;">(u32, in)
hm2_<i>&lt;BoardType&gt;</i>.<i>&lt;BoardNum&gt;</i>.dpll.plimit</p>

<p style="margin-left:22%;">Sets the phase adjustment limit
of the PLL. If the value is zero then the PLL will free-run
at the base frequency independent of the servo thread rate.
This is probably not what you want. Default 4194304
(0x400000) Units not known...</p>

<p style="margin-left:11%;">(u32, out)
hm2_<i>&lt;BoardType&gt;</i>.<i>&lt;BoardNum&gt;</i>.dpll.ddsize</p>

<p style="margin-left:22%;">Used internally by the driver,
likely to disappear.</p>

<p style="margin-left:11%;">(u32, in)
hm2_<i>&lt;BoardType&gt;</i>.<i>&lt;BoardNum&gt;</i>.dpll.prescale</p>

<p style="margin-left:22%;">Prescale factor for the rate
generator. Default 1.</p>

<h2>encoder
<a name="encoder"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Encoders have
names like
&quot;&quot;hm2_<i>&lt;BoardType&gt;</i>.<i>&lt;BoardNum&gt;</i>.encoder.<i>&lt;Instance&gt;</i>&quot;.&quot;.
&quot;Instance&quot; is a two-digit number that corresponds
to the HostMot2 encoder instance number. There are
&quot;num_encoders&quot; instances, starting with 00.</p>

<p style="margin-left:11%; margin-top: 1em">So, for
example, the HAL pin that has the current position of the
second encoder of the first 5i20 board is:
hm2_5i20.0.encoder.01.position (this assumes that the
firmware in that board is configured so that this HAL object
is available)</p>

<p style="margin-left:11%; margin-top: 1em">Each encoder
uses three or four input IO pins, depending on how the
firmware was compiled. Three-pin encoders use A, B, and
Index (sometimes also known as Z). Four-pin encoders use A,
B, Index, and Index-mask.</p>

<p style="margin-left:11%; margin-top: 1em">The hm2 encoder
representation is similar to the one described by the
Canonical Device Interface (in the HAL General Reference
document), and to the software encoder component. Each
encoder instance has the following pins and parameters:</p>

<p style="margin-left:11%; margin-top: 1em">Pins: <br>
(s32 out) count</p>

<p style="margin-left:22%;">Number of encoder counts since
the previous reset.</p>

<p style="margin-left:11%;">(float out) position</p>

<p style="margin-left:22%;">Encoder position in position
units (count / scale).</p>

<p style="margin-left:11%;">(float out) velocity</p>

<p style="margin-left:22%;">Estimated encoder velocity in
position units per second.</p>

<p style="margin-left:11%;">(float out) velocity-rpm</p>

<p style="margin-left:22%;">Estimated encoder velocity in
position units per minute.</p>

<p style="margin-left:11%;">(bit in) reset</p>

<p style="margin-left:22%;">When this pin is TRUE, the
count and position pins are set to 0. (The value of the
velocity pin is not affected by this.) The driver does not
reset this pin to FALSE after resetting the count to 0, that
is the user&rsquo;s job.</p>

<p style="margin-left:11%;">(bit in/out) index-enable</p>

<p style="margin-left:22%;">When this pin is set to True,
the count (and therefore also position) are reset to zero on
the next Index (Phase-Z) pulse. At the same time,
index-enable is reset to zero to indicate that the pulse has
occurred.</p>

<p style="margin-left:11%;">(s32 out) rawcounts</p>

<p style="margin-left:22%;">Total number of encoder counts
since the start, not adjusted for index or reset.</p>

<p style="margin-left:11%;">(bit out) input-a, input-b,
input-index</p>

<p style="margin-left:22%;">Real time filtered values of
A,B,Index encoder signals</p>

<p style="margin-left:11%;">(bit in) quad-error-enable</p>

<p style="margin-left:22%;">When this pin is true
quadrature error reporting is enabled. when false, existing
quadrature errors are cleared and error reporting is
disabled</p>

<p style="margin-left:11%;">(bit out) quad-error</p>

<p style="margin-left:22%;">This bit indicates that a
quadrature sequence error has been detected. It can only be
set if the corresponding quad-error-enable bit is true</p>

<p style="margin-left:11%;">(u32 in)
hm2_XXXX.N.encoder.sample-frequency</p>

<p style="margin-left:22%;">This is the sample frequency
that determines all standard encoder channels digital filter
time constant (see filter parameter)</p>

<p style="margin-left:11%;">(u32 in)
hm2_XXXX.N.encoder.muxed-sample-frequency</p>

<p style="margin-left:22%;">This is the sample frequency
that determines all muxed encoder channels digital filter
time constant (see filter parameter) This also sets the
encoder multiplexing frequency</p>

<p style="margin-left:11%;">(float in)
hm2_XXXX.N.encoder.muxed-skew</p>

<p style="margin-left:22%;">This sets the muxed encoder
sample time delay (in ns) from the multiplex signal. Setting
this properly can increase the usable multiplex frequency
and compensate for cable delays (suggested value is 3* cable
length in feet +20)</p>

<p style="margin-left:11%;">(bit in)
hm2_XXXX.N.encoder.hires-timestamp</p>

<p style="margin-left:22%;">When this pin is true the
encoder timestamp counter frequency is ~10 MHz when false
the timestamp counter frequency is ~2 MHz. This should be
set true for frequency counting applications to improve the
resolution. It should be set false when servo thread periods
longer than 1 ms are used.</p>


<p style="margin-left:22%; margin-top: 1em">Parameters:</p>

<p style="margin-left:11%;">(float r/w) scale</p>

<p style="margin-left:22%;">Converts from
&rsquo;count&rsquo; units to &rsquo;position&rsquo;
units.</p>

<p style="margin-left:11%;">(bit r/w) index-invert</p>

<p style="margin-left:22%;">If set to True, the rising edge
of the Index input pin triggers the Index event (if
index-enable is True). If set to False, the falling edge
triggers.</p>

<p style="margin-left:11%;">(bit r/w) index-mask</p>

<p style="margin-left:22%;">If set to True, the Index input
pin only has an effect if the Index-Mask input pin is True
(or False, depending on the index-mask-invert pin
below).</p>

<p style="margin-left:11%;">(bit r/w) index-mask-invert</p>

<p style="margin-left:22%;">If set to True, Index-Mask must
be False for Index to have an effect. If set to False, the
Index-Mask pin must be True.</p>

<p style="margin-left:11%;">(bit r/w) counter-mode</p>

<p style="margin-left:22%;">Set to False (the default) for
Quadrature. Set to True for Step/Dir (in which case Step is
on the A pin and Dir is on the B pin).</p>

<p style="margin-left:11%;">(bit r/w) filter</p>

<p style="margin-left:22%;">If set to True (the default),
the quadrature counter needs 15 sample clocks to register a
change on any of the three input lines (any pulse shorter
than this is rejected as noise). If set to False, the
quadrature counter needs only 3 clocks to register a change.
The default encoder sample clock runs at approximately 25 to
33 MHz but can be changed globally with the sample-frequency
or muxed-sample-frequency pin</p>

<p style="margin-left:11%;">(float r/w) vel-timeout</p>

<p style="margin-left:22%;">When the encoder is moving
slower than one pulse for each time that the driver reads
the count from the FPGA (in the hm2_read() function), the
velocity is harder to estimate. The driver can wait several
iterations for the next pulse to arrive, all the while
reporting the upper bound of the encoder velocity, which can
be accurately guessed. This parameter specifies how long to
wait for the next pulse, before reporting the encoder
stopped. This parameter is in seconds.</p>

<p style="margin-left:11%;">(s32 r/w)
hm2_XXXX.N.encoder.timer-number (default: -1)</p>

<p style="margin-left:22%;">Sets the hm2dpll timer instance
to be used to latch encoder counts. A setting of -1 does not
latch encoder counts. A setting of 0 latches at the same
time as the main hostmot2 read. A setting of 1..4 uses a
time offset from the main hostmot2 read according to the
dpll&rsquo;s timer-us setting.</p>

<p style="margin-left:22%; margin-top: 1em">Typically,
timer-us should be a negative number with a magnitude larger
than the largest latency (e.g., -100 for a system with
mediocre latency, -50 for a system with good latency).</p>

<p style="margin-left:22%; margin-top: 1em">If no DPLL
module is present in the FPGA firmware, or if the encoder
module does not support DPLL, then this pin is not
created.</p>

<p style="margin-left:22%; margin-top: 1em">When available,
this feature should typically be enabled. Doing so generally
reduces following errors.</p>

<h2>Synchronous Serial Interface (SSI)
<a name="Synchronous Serial Interface (SSI)"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">(Not to be
confused with the Smart Serial Interface)</p>

<p style="margin-left:11%; margin-top: 1em">One pin is
created for each SSI instance regardless of data format:
(bit, in) hm2_XXXX.NN.ssi.MM.data-incomplete This pin will
be set &quot;true&quot; if the module was still transferring
data when the value was read. When this problem exists there
will also be a limited number of error messages printed to
the UI. This pin should be used to monitor whether the
problem has been addressed by config changes. Solutions to
the problem dpend on whether the encoder read is being
triggered by the hm2dpll phase-locked-loop timer (described
above) or by the trigger-encoders function (described
below).</p>

<p style="margin-left:11%; margin-top: 1em">The names of
the pins created by the SSI module will depend entirely on
the format string for each channel specified in the loadrt
command line. A typical format string might be <b><br>
ssi_chan_0=error%1bposition%24g</b></p>

<p style="margin-left:11%; margin-top: 1em">This would
interpret the LSB of the bit-stream as a bit-type pin named
&quot;error&quot; and the next 24 bits as a Gray-coded
encoder counter. The encoder-related HAL pins would all
begin with &quot;position&quot;.</p>

<p style="margin-left:11%; margin-top: 1em">There should be
no spaces in the format string, as this is used as a
delimiter by the low-level code.</p>

<p style="margin-left:11%; margin-top: 1em">The format
consists of a string of alphanumeric characters that will
form the HAL pin names, followed by a % symbol, a bit-count
and a data type. All bits in the packet must be defined,
even if they are not used. There is a limit of 64 bits in
total.</p>

<p style="margin-left:11%; margin-top: 1em">The valid
format characters and the pins they create are: <br>
p: (Pad). Does not create any pins, used to ignore sections
of the bit <br>
stream that are not required. <br>
b: (Boolean).</p>

<p style="margin-left:22%;">(bit, out)
hm2_XXXX.N.ssi.MM.&lt;name&gt;. If any bits in the
designated field width are non-zero then the HAL pin will be
&quot;true&quot;. <br>
(bit, out) hm2_XXXX.N.ssi.MM.&lt;name&gt;-not. An inverted
version of the above, the HAL pin will be &quot;true&quot;
if all bits in the field are zero.</p>

<p style="margin-left:11%;">u: (Unsigned)</p>

<p style="margin-left:22%;">(float, out)
hm2_XXXX.N.ssi.MM.&lt;name&gt;. The value of the bits
interpreted as an unsigned integer then scaled such that the
pin value will equal the scalemax parameter value when all
bits are high. (for example if the field is 8 bits wide and
the scalmax parameter was 20 then a value of 255 would
return 20, and 0 would return 0.</p>

<p style="margin-left:11%;">s: (Signed)</p>

<p style="margin-left:22%;">(float, out)
hm2_XXXX.N.ssi.MM.&lt;name&gt;. The value of the bits
interpreted as a 2s complement signed number then scaled
similarly to the unsigned variant, except symmetrical around
zero.</p>

<p style="margin-left:11%;">f: (bitField)</p>

<p style="margin-left:22%;">(bit, out)
hm2_XXXX.N.ssi.MM.&lt;name&gt;-NN. The value of each
individual bit in the data field. NN starts at 00 up to the
number of bits in the field. <br>
(bit, out) hm2_XXXX.N.ssi.MM.&lt;name&gt;-NN-not. An
inverted version of the individual bit values.</p>

<p style="margin-left:11%;">e: (Encoder)</p>

<p style="margin-left:22%;">(s32, out)
hm2_XXXX.N.ssi.MM.&lt;name&gt;.count. The lower 32 bits of
the total encoder counts. This value is reset both by the
...reset and the ...index-enable pins. <br>
(s32, out) hm2_XXXX.N.ssi.MM.&lt;name&gt;.rawcounts. The
lower 32 bits of the total encoder counts. The pin is not
affected by reset and index. <br>
(float, out) hm2_XXXX.N.ssi.MM.&lt;name&gt;.position. The
encoder position in machine units. This is calculated from
the full 64-bit buffers so will show a true value even after
the counts pins have wrapped. It is zeroed by reset and
index enable. <br>
(bit, IO) hm2_XXXX.N.ssi.MM.&lt;name&gt;.index-enable. When
this pin is set &quot;true&quot; the module will wait until
the raw encoder counts next passes through an integer
multiple of the number of counts specified by counts-per-rev
parameter and then it will zero the counts and position
pins, and set the index-enable pin back to &quot;false&quot;
as a signal to the system that &quot;index&quot; has been
passed. this pin is used for spindle-synchronised motion and
index-homing. <br>
(bit, in) (bit, out) hm2_XXXX.N.ssi.MM.&lt;name&gt;.reset.
When this pin is set high the counts and position pins are
zeroed.</p>

<p style="margin-left:11%;">h: (Split encoder, high-order
bits)</p>

<p style="margin-left:22%;">Some encoders (Including Fanuc)
place the encoder part-turn counts and full-turn counts in
separate, non-contiguous fields. This tag defines the
high-order bits of such an encoder module. There can be only
one h and one l tag per channel, the behaviour with multiple
such channels will be undefined.</p>

<p style="margin-left:11%;">l: (Split encoder, low-order
bits)</p>

<p style="margin-left:22%;">Low order bits (see
&quot;h&quot;)</p>

<p style="margin-left:11%;">g: (Gray-code). This is a
modifier that indicates that the following</p>

<p style="margin-left:22%;">format string is gray-code
encoded. This is only valid for encoders (e, h l) and
unsigned (u) data types.</p>

<p style="margin-left:11%;">m: (Multi-turn). This is a
modifier that indicates that the following</p>

<p style="margin-left:22%;">format string is a multi-turn
encoder. This is only valid for encoders (e, h l). A jump in
encoder position of more than half the full scale is
interpreted as a full turn and the counts are wrapped. With
a multi-turn encoder this is only likely to be a data glitch
and will lead to a permanent offset. This flag endures that
such encoders will never wrap.</p>

<p style="margin-left:11%;">Parameters:</p>

<p style="margin-left:22%;">Two parameters is universally
created for all SSI instances</p>

<p style="margin-left:11%;">(float r/w)
hm2_XXXX.N.ssi.MM.frequency-khz</p>

<p style="margin-left:22%;">This parameter sets the SSI
clock frequency. The units are kHz, so 500 will give a clock
frequency of 500,000 Hz.</p>

<p style="margin-left:11%;">(s32 r/w)
hm2_XXXX.N.ssi.timer-number-num</p>

<p style="margin-left:22%;">This parameter allocates the
SSI module to a specific hm2dpll timer instance. This pin is
only of use in firmwares which contain a hm2dpll function
and will default to 1 in cases where there is such a
function, and 0 if there is not. The pin can be used to
disable reads of the encoder, by setting to a nonexistent
timer number, or to 0.</p>

<p style="margin-left:22%; margin-top: 1em">Other
parameters depend on the data types specified in the config
string.</p>

<p style="margin-left:11%;">p: (Pad) No Parameters. <br>
b: (Boolean) No Parameters. <br>
u: (Unsigned)</p>

<p style="margin-left:22%;">(float, r/w)
hm2_XXXX.N.ssi.MM.&lt;name&gt;-scalemax. The scaling factor
for the <br>
channel.</p>

<p style="margin-left:11%;">s: (Signed)</p>

<p style="margin-left:22%;">(float, r/w)
hm2_XXXX.N.ssi.MM.&lt;name&gt;-scalemax. The scaling factor
for the channel.</p>

<p style="margin-left:11%;">f: (bitField): No parameters.
<br>
e: (Encoder):</p>

<p style="margin-left:22%;">(float, r/w)
hm2_XXXX.N.ssi.MM.&lt;name&gt;.scale: (float, r.w) The
encoder scale in counts per machine unit. <br>
(u32, r/w) hm2_XXXX.N.ssi.MM.&lt;name&gt;.counts-per-rev
(u32, r/w) Used to emulate the index behaviour of an
incemental+index encoder. This would normally be set to the
actual counts per rev of the encoder, but can be any whole
number of revs. Integer divisors or multimpilers of the true
PPR might be useful for index-homing. Non-integer factors
might be appropriate where there is a synchronous drive
ratio between the encoder and the spindle or ballscrew.</p>

<h2>BiSS
<a name="BiSS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">BiSS is a
bidirectional variant of SSI. Currently only a single
direction is supported by LinuxCNC (encoder to PC).</p>

<p style="margin-left:11%; margin-top: 1em">One pin is
created for each BiSS instance regardless of data
format:</p>

<p style="margin-left:11%; margin-top: 1em">(bit, in)
hm2_XXXX.NN.biss.MM.data-incomplete This pin will be set
&quot;true&quot; if the module was still transferring data
when the value was read. When this problem exists there will
also be a limited number of error messages printed to the
UI. This pin should be used to monitor whether the problem
has been addressed by config changes. Solutions to the
problem dpend on whether the encoder read is being triggered
by the hm2dpll phase-locked-loop timer (described above) or
by the trigger-encoders function (described below)</p>

<p style="margin-left:11%; margin-top: 1em">The names of
the pins created by the BiSS module will depend entirely on
the format string for each channel specified in the loadrt
command line and follow closely the format defined above for
SSI. Currently data packets of up to 96 bits are supported
by the LinuxCNC driver, although the Mesa Hostmot2 module
can handle 512 bit packets. It should be possible to extend
the number of packets supported by the driver if there is a
requirement to do so.</p>

<h2>Fanuc encoder.
<a name="Fanuc encoder."></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The pins and
format specifier for this module are identical to the SSI
module described above, except that at least one
pre-configured format is provided. A modparam of
fanuc_chan_N=AA64 (case sensitive) will configure the
channel for a Fanuc Aa64 encoder. The pins created are: <br>
hm2_XXXX.N.fanuc.MM.batt indicates battery state <br>
hm2_XXXX.N.fanuc.MM.batt-not inverted version of above <br>
hm2_XXXX.N.fanuc.MM.comm The 0-1023 absolute output for
motor commutation <br>
hm2_XXXX.N.fanuc.MM.crc The CRC checksum. Currently HAL has
no way to use this <br>
hm2_XXXX.N.fanuc.MM.encoder.count Encoder counts <br>
hm2_XXXX.N.fanuc.MM.encoder.index-enable Simulated index.
Set by counts-per-rev parameter <br>
hm2_XXXX.N.fanuc.MM.encoder.position Counts scaled by the
...scale parameter <br>
hm2_XXXX.N.fanuc.MM.encoder.rawcounts Raw counts, unaffected
by reset or index <br>
hm2_XXXX.N.fanuc.MM.encoder.reset If high/true then counts
and position = 0 <br>
hm2_XXXX.N.fanuc.MM.valid Indicates that the absolute
position is valid <br>
hm2_XXXX.N.fanuc.MM.valid-not Inverted version</p>

<h2>resolver
<a name="resolver"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Resolvers have
names like
hm2_<i>&lt;BoardType&gt;</i>.<i>&lt;BoardNum&gt;</i>.resolver.<i>&lt;Instance&gt;</i>.
&lt;Instance is a 2-digit number, which for the 7i49 board
will be between 00 and 05. This function only works with the
Mesa Resolver interface boards (of which the 7i49 is the
only example at the time of writing). This board uses an SPI
interface to the FPGA card, and will only work with the
correct firmware. The pins allocated will be listed in the
dmesg output, but are unlikely to be usefully probed with
HAL tools.</p>

<p style="margin-left:11%; margin-top: 1em">Pins: <br>
(float, out) angle</p>

<p style="margin-left:22%;">This pin indicates the angular
position of the resolver. It is a number between 0 and 1 for
each electrical rotation.</p>

<p style="margin-left:11%;">(float, out) position</p>

<p style="margin-left:22%;">Calculated from the number of
complete and partial revolutions since startup, reset, or
index-reset multiplied by the scale parameter.</p>

<p style="margin-left:11%;">(float, out) velocity</p>

<p style="margin-left:22%;">Calculated from the rotational
velocity and the velocity-scale parameter. The default scale
is electrical rotations per second.</p>

<p style="margin-left:11%;">(float, out) velocity-rpm</p>

<p style="margin-left:22%;">Simply velocity scaled by a
factor of 60 for convenience.</p>

<p style="margin-left:11%;">(s32, out) count</p>

<p style="margin-left:22%;">This pins outputs a simulated
encoder count at 2^24 counts per rev (16777216 counts).</p>

<p style="margin-left:11%;">(s32, out) rawcounts</p>

<p style="margin-left:22%;">This is identical to the counts
pin, except it is not reset by the &rsquo;index&rsquo; or
&rsquo;reset&rsquo; pins. This is the pin which would be
linked to the bldc HAL component if the resolver was being
used to commutate a motor.</p>

<p style="margin-left:11%;">(bit, in) reset</p>

<p style="margin-left:22%;">Resets the position and counts
pins to zero immediately.</p>

<p style="margin-left:11%;">(bit, in) joint-pos-fb</p>

<p style="margin-left:22%;">The Mesa resolver driver has
the capability of emulating an absolute encoder using a
position file (see the INI-config section of the manual) and
the single-turn absolute operation of resolvers. At startup,
and only if the <b>use-position-file</b> parameter is set to
&quot;true&quot; the resolver driver will wait for a value
to be written by the system to the axis.N.joint-pos-fb pin
(which must be netted to this resolver pin) and will
calculate the number of full turns that best matches the
current reolver position. It will then pre-load the driver
output with this offset. This should only be used on systems
where axis movement in the unpowered state is unlikely. This
feature will only work properly if the machine is initially
homed to &quot;index&quot; and if the axis home positions
are exactly zero.</p>

<p style="margin-left:11%;">(bit, in/out) index-enable</p>

<p style="margin-left:22%;">When this pin is set high the
position and counts pins will be reset the next time the
resolver passes through the zero position. At the same time
the pin is driven low to indicate to connected modules that
the index has been seen, and that the counters have been
reset.</p>

<p style="margin-left:11%;">(bit, out) error</p>

<p style="margin-left:22%;">Indicates an error in the
particular channel. If this value is &quot;true&quot; then
the reported position and velocity are invalid.</p>


<p style="margin-left:22%; margin-top: 1em">Parameters:</p>

<p style="margin-left:11%;">(float, read/write) scale</p>

<p style="margin-left:22%;">The position scale, in machine
units per resolver electrical revolution.</p>

<p style="margin-left:11%;">(float, read/write)
velocity-scale</p>

<p style="margin-left:22%;">The conversion factor between
resolver rotation speed and machine velocity. A value of 1
will typically give motor speed in rps, a value of
0.01666667 will give (approximate) RPM.</p>

<p style="margin-left:11%;">(u32, read/write) index-divisor
(default 1)</p>

<p style="margin-left:22%;">The resolver component emulates
an index at a fixed point in the sin/cos cycle. Some
resolvers have multiple cycles per rev (often related to the
number of pole-pairs on the attached motor). LinuxCNC
requires an index once per revolution for proper threading
etc. This parameter should be set to the number of cycles
per rev of the resolver. CAUTION: Which pseudo-index is used
will not necessarily be consistent between LinuxCNC runs. Do
not expect to re-start a thread after restarting LinuxCNC.
It is not appropriate to use this parameter for index-homing
of axis drives.</p>

<p style="margin-left:11%;">(float, read/write)
excitation-khz</p>

<p style="margin-left:22%;">This pin sets the excitation
frequency for the resolver. This pin is module-level rather
than instance-level as all resolvers share the same
excitation frequency. <br>
Valid values are 10 (~10kHz), 5 (~5kHz) and 2.5 (~2.5kHz).
The actual frequency depends on the FPGA frequency, and they
correspond to CLOCK_LOW/5000, CLOCK_LOW/10000 and
CLOCK_LOW/20000 respectively. The parameter will be set to
the closest available of the three frequencies. <br>
A value of -1 (the default) indicates that the current
setting should be retained.</p>

<p style="margin-left:11%;">(bit, read/write)
use-position-file</p>

<p style="margin-left:22%;">In conjunction with
<b>joint-pos-fb</b> (qv) emulate absolute encoders.</p>

<h2>pwmgen
<a name="pwmgen"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">pwmgens have
names like
&quot;hm2_<i>&lt;BoardType&gt;</i>.<i>&lt;BoardNum&gt;</i>.pwmgen.<i>&lt;Instance&gt;</i>&quot;.
&quot;Instance&quot; is a two-digit number that corresponds
to the HostMot2 pwmgen instance number. There are
&rsquo;num_pwmgens&rsquo; instances, starting with 00.</p>

<p style="margin-left:11%; margin-top: 1em">So, for
example, the HAL pin that enables output from the fourth
pwmgen of the first 7i43 board is:
hm2_7i43.0.pwmgen.03.enable (this assumes that the firmware
in that board is configured so that this HAL object is
available)</p>

<p style="margin-left:11%; margin-top: 1em">In HM2, each
pwmgen uses three output IO pins: Not-Enable, Out0, and
Out1.</p>

<p style="margin-left:11%; margin-top: 1em">The function of
the Out0 and Out1 IO pins varies with output-type parameter
(see below).</p>

<p style="margin-left:11%; margin-top: 1em">The hm2 pwmgen
representation is similar to the software pwmgen component.
Each pwmgen instance has the following pins and
parameters:</p>

<p style="margin-left:11%; margin-top: 1em">Pins: <br>
(bit input) enable</p>

<p style="margin-left:22%;">If true, the pwmgen will set
its Not-Enable pin false and output its pulses. If
&rsquo;enable&rsquo; is false, pwmgen will set its
Not-Enable pin true and not output any signals.</p>

<p style="margin-left:11%;">(float input) value</p>

<p style="margin-left:22%;">The current pwmgen command
value, in arbitrary units.</p>


<p style="margin-left:22%; margin-top: 1em">Parameters:</p>

<p style="margin-left:11%;">(float rw) scale</p>

<p style="margin-left:22%;">Scaling factor to convert
&rsquo;value&rsquo; from arbitrary units to duty cycle: dc =
value / scale. Duty cycle has an effective range of -1.0 to
+1.0 inclusive, anything outside that range gets clipped.
The default scale is 1.0.</p>

<p style="margin-left:11%;">(s32 rw) output-type</p>

<p style="margin-left:22%;">This emulates the output_type
load-time argument to the software pwmgen component. This
parameter may be changed at runtime, but most of the time
you probably want to set it at startup and then leave it
alone. Accepted values are 1 (PWM on Out0 and Direction on
Out1), 2 (Up on Out0 and Down on Out1), 3 (PDM mode, PDM on
Out0 and Dir on Out1), and 4 (Direction on Out0 and PWM on
Out1, &quot;for locked antiphase&quot;).</p>

<p style="margin-left:11%;">(bit input) offset-mode</p>

<p style="margin-left:22%;">When true, offset-mode modifies
the PWM behavior so that a PWM value of 0 results in a 50%
duty cycle PWM output, a -1 value results in a 0% duty cycle
and +1 results in a 100% duty cycle (with default scaling)
This mode is used by some PWM motor drives and PWM to analog
converters. Typically the direction signal is not used in
this mode.</p>

<p style="margin-left:22%; margin-top: 1em">In addition to
the per-instance HAL Parameters listed above, there are a
couple of HAL Parameters that affect all the pwmgen
instances:</p>

<p style="margin-left:11%;">(u32 rw) pwm_frequency</p>

<p style="margin-left:22%;">This specifies the PWM
frequency, in Hz, of all the pwmgen instances running in the
PWM modes (modes 1 and 2). This is the frequency of the
variable-duty-cycle wave. Its effective range is from 1 Hz
up to 193 kHz. Note that the max frequency is determined by
the ClockHigh frequency of the Anything IO board; the 5i20
and 7i43 both have a 100 MHz clock, resulting in a 193 kHz
max PWM frequency. Other boards may have different clocks,
resulting in different max PWM frequencies. If the user
attempts to set the frequency too high, it will be clipped
to the max supported frequency of the board. Frequencies
below about 5 Hz are not terribly accurate, but above 5 Hz
they&rsquo;re pretty close. The default pwm_frequency is
20,000 Hz (20 kHz).</p>

<p style="margin-left:11%;">(u32 rw) pdm_frequency</p>

<p style="margin-left:22%;">This specifies the PDM
frequency, in Hz, of all the pwmgen instances running in PDM
mode (mode 3). This is the &quot;pulse slot frequency&quot;;
the frequency at which the pdm generator in the AnyIO board
chooses whether to emit a pulse or a space. Each pulse (and
space) in the PDM pulse train has a duration of
1/pdm_frequency seconds. For example, setting the
pdm_frequency to 2e6 (2 MHz) and the duty cycle to 50%
results in a 1 MHz square wave, identical to a 1 MHz PWM
signal with 50% duty cycle. The effective range of this
parameter is from about 1525 Hz up to just under 100 MHz.
Note that the max frequency is determined by the ClockHigh
frequency of the Anything IO board; the 5i20 and 7i43 both
have a 100 MHz clock, resulting in a 100 Mhz max PDM
frequency. Other boards may have different clocks, resulting
in different max PDM frequencies. If the user attempts to
set the frequency too high, it will be clipped to the max
supported frequency of the board. The default pdm_frequency
is 20,000 Hz (20 kHz).</p>

<h2>3ppwmgen
<a name="3ppwmgen"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Three-Phase PWM
generators (3pwmgens) are intended for controlling the
high-side and low-side gates in a 3-phase motor driver. The
function is included to support the Mesa motor controller
daughter-cards but can be used to control an IGBT or similar
driver directly. 3pwmgens have names like
&quot;hm2_<i>&lt;BoardType&gt;</i>.<i>&lt;BoardNum&gt;</i>.3pwmgen.<i>&lt;Instance&gt;</i>&quot;
where &lt;Instance&gt; is a 2-digit number. There will be
num_3pwmgens instances, starting at 00. Each instance
allocates 7 output and one input pins on the Mesa card
connectors. Outputs are: PWM A, PWM B, PWM C, /PWM A, /PWM
B, /PWM C, Enable. The first three pins are the high side
drivers, the second three are their complementary low-side
drivers. The enable bit is intended to control the servo
amplifier. The input bit is a fault bit, typically wired to
over-current detection. When set the PWM generator is
disabled. The three phase duty-cycles are individually
controllable from -Scale to +Scale. Note that 0 corresponds
to a 50% duty cycle and this is the inialization value.</p>

<p style="margin-left:11%; margin-top: 1em">Pins:</p>

<p style="margin-left:11%; margin-top: 1em">(float input)
A-value, B-value, C-value: The PWM command value for each
phase, limited to +/- &quot;scale&quot;. Defaults to zero
which is 50% duty cycle on high-side and low-sidepins (but
see the &quot;deadtime&quot; parameter) <br>
(bit input) enable</p>

<p style="margin-left:22%;">When high the PWM is enabled as
long as the fault bit is not set by the external fault input
pin. When low the PWM is disabled, with both high- side and
low-side drivers low. This is not the same as 0 output (50%
duty cycle on both sets of pins) or negative full scale
(where the low side drivers are &quot;on&quot; 100% of the
time)</p>

<p style="margin-left:11%;">(bit output) fault</p>

<p style="margin-left:22%;">Indicates the status of the
fault bit. This output latches high once set by the physical
fault pin until the &quot;enable&quot; pin is set to
high.</p>


<p style="margin-left:22%; margin-top: 1em">Parameters:</p>

<p style="margin-left:11%;">(u32 rw) deadtime</p>

<p style="margin-left:22%;">Sets the dead-time between the
high-side driver turning off and the low-side driver turning
on and vice-versa. Deadtime is subtracted from on time and
added to off time symmetrically. For example with 20 kHz PWM
(50 uSec period), 50% duty cycle and zero dead time, the PWM
and NPWM outputs would be square waves (NPWM being inverted
from PWM) with high times of 25 uS. With the same settings
but 1 uS of deadtime, the PWM and NPWM outputs would both
have high times of 23 uS (25 - (2X 1 uS), 1 uS per edge).
The value is specified in nS and defaults to a rather
conservative 5000nS. Setting this parameter to too low a
value could be both expensive and dangerous as if both gates
are open at the same time there is effectively a short
circuit across the supply.</p>

<p style="margin-left:11%;">(float rw) scale</p>

<p style="margin-left:22%;">Sets the half-scale of the
specified 3-phase PWM generator. PWM values from -scale to
+scale are valid. Default is +/- 1.0</p>

<p style="margin-left:11%;">(bit rw) fault-invert</p>

<p style="margin-left:22%;">Sets the polarity of the fault
input pin. A value of 1 means that a fault is triggered with
the pin high, and 0 means that a fault it triggered when the
pin is pulled low. Default 0, fault = low so that the PWM
works with the fault pin unconnected.</p>

<p style="margin-left:11%;">(u32 rw) sample-time</p>

<p style="margin-left:22%;">Sets the time during the cycle
when an ADC pulse is generated. 0 = start of PWM cycle and 1
= end. Not currently useful to LinuxCNC. Default 0.5.</p>

<p style="margin-left:22%; margin-top: 1em">In addition the
per-instance parameters above there is the following
parameter that affects all instances</p>

<p style="margin-left:11%;">(u32 rw) frequency</p>

<p style="margin-left:22%;">Sets the master PWM frequency.
Maximum is approx 48kHz, minimum is 1kHz. Defaults to
20kHz.</p>

<h2>rcpwmgen
<a name="rcpwmgen"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The rcpwmgen is
a simple PWM generator optimized for use with standard RC
servos that use pulse width to determine position. rcpwmgens
have names like
&quot;hm2_<i>&lt;BoardType&gt;</i>.<i>&lt;BoardNum&gt;</i>.rcpwmgen.<i>&lt;Instance&gt;</i>&quot;
where &lt;Instance&gt; is a 2-digit number. There will be
num_rcpwmgens instances, starting at 00. Each instance
allocates a single output pin. Unlike the standard PWM
generator, the rcpwmgen output is specified in width rather
than duty cycle so the pulse width is independent of the
operating frequency. Resolution is approximately 1/2000 for
standard 1 to 2 mS range RC servos.</p>

<p style="margin-left:11%; margin-top: 1em">Pins: <br>
(float rw) rate</p>

<p style="margin-left:22%;">Sets the master RC PWM
frequency. Maximum is 1 KHz, minimum is .01 Hz. Defaults to
50 Hz.</p>

<p style="margin-left:11%;">(float rw) width</p>

<p style="margin-left:22%;">Sets the per channel pulse
width in (mS/scale)</p>

<p style="margin-left:11%;">(float rw) offset</p>

<p style="margin-left:22%;">Sets the per channel pulse
width offset in mS. This would be set to 1.5 mS for 1-2 mS
servos for a 0 center position.</p>

<p style="margin-left:11%;">(float rw) scale</p>

<p style="margin-left:22%;">Sets the per channel pulse
width scaling, for example, setting the scale to 90 and the
offset to 1.5 mS would result in a position range of +-45
degrees scale in degrees for 1-2 mS servos with a full
motion range of 90 degrees</p>

<h2>stepgen
<a name="stepgen"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">stepgens have
names like
&quot;hm2_<i>&lt;BoardType&gt;</i>.<i>&lt;BoardNum&gt;</i>.stepgen.<i>&lt;Instance&gt;</i>&quot;.
&quot;Instance&quot; is a two-digit number that corresponds
to the HostMot2 stepgen instance number. There are
&rsquo;num_stepgens&rsquo; instances, starting with 00.</p>

<p style="margin-left:11%; margin-top: 1em">So, for
example, the HAL pin that has the current position feedback
from the first stepgen of the second 5i22 board is:
hm2_5i22.1.stepgen.00.position-fb (this assumes that the
firmware in that board is configured so that this HAL object
is available)</p>

<p style="margin-left:11%; margin-top: 1em">Each stepgen
uses between 2 and 6 IO pins. The signals on these pins
depends on the step_type parameter (described below).</p>

<p style="margin-left:11%; margin-top: 1em">The stepgen
representation is modeled on the stepgen software component.
Each stepgen instance has the following pins and
parameters:</p>

<p style="margin-left:11%; margin-top: 1em">Pins: <br>
(float input) position-cmd</p>

<p style="margin-left:22%;">Target position of stepper
motion, in arbitrary position units. This pin is only used
when the stepgen is in position control mode
(control-type=0).</p>

<p style="margin-left:11%;">(float input) velocity-cmd</p>

<p style="margin-left:22%;">Target velocity of stepper
motion, in arbitrary position units per second. This pin is
only used when the stepgen is in velocity control mode
(control-type=1).</p>

<p style="margin-left:11%;">(s32 output) counts</p>

<p style="margin-left:22%;">Feedback position in counts
(number of steps).</p>

<p style="margin-left:11%;">(float output) position-fb</p>

<p style="margin-left:22%;">Feedback position in arbitrary
position units. This is similar to
&quot;counts/position_scale&quot;, but has finer than step
resolution.</p>

<p style="margin-left:11%;">(float output) velocity-fb</p>

<p style="margin-left:22%;">Feedback velocity in arbitrary
position units per second.</p>

<p style="margin-left:11%;">(bit input) enable</p>

<p style="margin-left:22%;">This pin enables the step
generator instance. When True, the stepgen instance works as
expected. When False, no steps are generated and velocity-fb
goes immediately to 0. If the stepgen is moving when enable
goes false it stops immediately, without obeying the
maxaccel limit.</p>

<p style="margin-left:11%;">(bit input) control-type</p>

<p style="margin-left:22%;">Switches between position
control mode (0) and velocity control mode (1). Defaults to
position control (0).</p>


<p style="margin-left:22%; margin-top: 1em">Parameters:</p>

<p style="margin-left:11%;">(float r/w) position-scale</p>

<p style="margin-left:22%;">Converts from counts to
position units. position = counts / position_scale</p>

<p style="margin-left:11%;">(float r/w) maxvel</p>

<p style="margin-left:22%;">Maximum speed, in position
units per second. If set to 0, the driver will always use
the maximum possible velocity based on the current step
timings and position-scale. The max velocity will change if
the step timings or position-scale changes. Defaults to
0.</p>

<p style="margin-left:11%;">(float r/w) maxaccel</p>

<p style="margin-left:22%;">Maximum acceleration, in
position units per second per second. Defaults to 1.0. If
set to 0, the driver will not limit its acceleration at all
- this requires that the position-cmd or velocity-cmd pin is
driven in a way that does not exceed the machine&rsquo;s
capabilities. This is probably what you want if you&rsquo;re
going to be using the LinuxCNC trajectory planner to jog or
run G-code.</p>

<p style="margin-left:11%;">(u32 r/w) steplen</p>

<p style="margin-left:22%;">Duration of the step signal, in
nanoseconds.</p>

<p style="margin-left:11%;">(u32 r/w) stepspace</p>

<p style="margin-left:22%;">Minimum interval between step
signals, in nanoseconds.</p>

<p style="margin-left:11%;">(u32 r/w) dirsetup</p>

<p style="margin-left:22%;">Minimum duration of stable
Direction signal before a step begins, in nanoseconds.</p>

<p style="margin-left:11%;">(u32 r/w) dirhold</p>

<p style="margin-left:22%;">Minimum duration of stable
Direction signal after a step ends, in nanoseconds.</p>

<p style="margin-left:11%;">(u32 r/w) step_type</p>

<p style="margin-left:22%;">Output format, like the
step_type modparam to the software stegen(9) component. 0 =
Step/Dir, 1 = Up/Down, 2 = Quadrature, 3+ = table-lookup
mode. In this mode the step_type parameter determines how
long the step sequence is. Additionally the stepgen_width
parameter in the loadrt config string must be set to suit
the number of pins per stepgen required. Any stepgen pins
above this number will be available for GPIO. This mask
defaults to 2. The maximum length is 16. Note that Table
mode is not enabled in all firmwares but if you see GPIO
pins between the stepgen instances in the dmesg/log hardware
pin list then the option may be available.</p>

<p style="margin-left:22%; margin-top: 1em">In Quadrature
mode (step_type=2), the stepgen outputs one complete Gray
cycle (00 &acirc; 01 &acirc; 11 &acirc; 10 &acirc; 00) for
each &quot;step&quot; it takes. In table mode up to 6 IO
pins are individually controlled in an arbitrary sequence up
to 16 phases long.</p>

<p style="margin-left:11%;">(u32 r/w) table-data-N</p>

<p style="margin-left:22%;">There are 4 table-data-N
parameters, table-data-0 to table-data-3. These each contain
4 bytes corresponding to 4 stages in the step sequence. For
example table-data-0 = 0x00000001 would set stepgen pin 0
(always called &quot;Step&quot; in the dmesg output) on the
first phase of the step sequence, and table-data-4 =
0x20000000 would set stepgen pin 6 (&quot;Table5Pin&quot; in
the dmesg output) on the 16th stage of the step
sequence.</p>

<p style="margin-left:11%;">(s32 r/w)
hm2_XXXX.N.stepgen.timer-number (default: -1)</p>

<p style="margin-left:22%;">Sets the hm2dpll timer instance
to be used to latch stepgen counts. A setting of -1 does not
latch encoder counts. A setting of 0 latches at the same
time as the main hostmot2 write. A setting of 1..4 uses a
time offset from the main hostmot2 write according to the
dpll&rsquo;s timer-us setting.</p>

<p style="margin-left:22%; margin-top: 1em">Typically,
timer-us should be a negative number with a magnitude larger
than the largest latency (e.g., -100 for a system with
mediocre latency, -50 for a system with good latency).</p>

<p style="margin-left:22%; margin-top: 1em">If no DPLL
module is present in the FPGA firmware, or if the stepgen
module does not support DPLL, then this pin is not
created.</p>

<p style="margin-left:22%; margin-top: 1em">When available,
this feature should typically be enabled. Doing so generally
reduces following errors.</p>

<h2>Smart Serial Interface
<a name="Smart Serial Interface"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The Smart
Serial Interface allows up to 32 different devices such as
the Mesa 8i20 2.2kW 3-phase drive or 7i64 48-way IO cards to
be connected to a single FPGA card. The driver auto-detects
the connected hardware port, channel and device type.
Devices can be connected in any order to any active channel
of an active port. (see the config modparam definition
above).</p>

<p style="margin-left:11%; margin-top: 1em">For full
details of the smart-serial devices see <b>man
sserial</b>.</p>

<h2>BSPI
<a name="BSPI"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The BSPI
(Buffered SPI) driver is unusual in that it does not create
any HAL pins. Instead the driver exports a set of functions
that can be used by a sub-driver for the attached hardware.
Typically these would be written in the &quot;comp&quot;</p>

<p style="margin-left:11%; margin-top: 1em">pre-processing
language: see http://linuxcnc.org/docs/html/hal/comp.html or
man halcompile for further details. See man mesa_7i65 and
the source of mesa_7i65.comp for details of a typical
sub-driver. See man hm2_bspi_setup_chan, man
hm2_bspi_write_chan, man hm2_tram_add_bspi_frame, man
hm2_allocate_bspi_tram, man hm2_bspi_set_read_funtion and
man hm2_bspi_set_write_function for the exported
functions.</p>

<p style="margin-left:11%; margin-top: 1em">The names of
the available channels are printed to standard output during
the driver loading process and take the form hm2_&lt;board
name&gt;.&lt;board index&gt;.bspi.&lt;index&gt; For example
hm2_5i23.0.bspi.0</p>

<h2>UART
<a name="UART"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The UART driver
also does not create any HAL pins, instead it declares two
simple read/write functions and a setup function to be
utilised by user-written code. Typically this would be
written in the &quot;comp&quot; pre-processing language: see
http://linuxcnc.org/docs/html/hal/comp.html or man
halcompile for further details. See man mesa_uart and the
source of mesa_uart.comp for details of a typical
sub-driver. See man hm2_uart_setup_chan, man hm2_uart_send,
man hm2_uart_read and man hm2_uart_setup.</p>

<p style="margin-left:11%; margin-top: 1em">The names of
the available uart channels are printed to standard output
during the driver loading process and take the form
hm2_&lt;board name&gt;.&lt;board index&gt;uart.&lt;index&gt;
For example hm2_5i23.0.uart.0</p>

<h2>General Purpose I/O
<a name="General Purpose I/O"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">I/O pins on the
board which are not used by a module instance are exported
to HAL as &quot;full&quot; GPIO pins. Full GPIO pins can be
configured at run-time to be inputs, outputs, or open
drains, and have a HAL interface that exposes this
flexibility. IO pins that are owned by an active module
instance are constrained by the requirements of the owning
module, and have a restricted HAL interface.</p>

<p style="margin-left:11%; margin-top: 1em">GPIOs have
names like
&quot;hm2_<i>&lt;BoardType&gt;</i>.<i>&lt;BoardNum&gt;</i>.gpio.<i>&lt;IONum&gt;</i>&quot;.
IONum is a three-digit number. The mapping from IONum to
connector and pin-on-that-connector is written to the syslog
when the driver loads, and it&rsquo;s documented in
Mesa&rsquo;s manual for the Anything I/O boards.</p>

<p style="margin-left:11%; margin-top: 1em">So, for
example, the HAL pin that has the current inverted input
value read from GPIO 012 of the second 7i43 board is:
hm2_7i43.1.gpio.012.in-not (this assumes that the firmware
in that board is configured so that this HAL object is
available)</p>

<p style="margin-left:11%; margin-top: 1em">The HAL
parameter that controls whether the last GPIO of the first
5i22 is an input or an output is:
hm2_5i22.0.gpio.095.is_output (this assumes that the
firmware in that board is configured so that this HAL object
is available)</p>

<p style="margin-left:11%; margin-top: 1em">The hm2 GPIO
representation is modeled after the Digital Inputs and
Digital Outputs described in the Canonical Device Interface
(part of the HAL General Reference document). Each GPIO can
have the following HAL Pins: <br>
(bit out) in &amp; in_not</p>

<p style="margin-left:22%;">State (normal and inverted) of
the hardware input pin. Both full GPIO pins and IO pins used
as inputs by active module instances have these pins.</p>

<p style="margin-left:11%;">(bit in) out</p>

<p style="margin-left:22%;">Value to be written (possibly
inverted) to the hardware output pin. Only full GPIO pins
have this pin.</p>

<p style="margin-left:11%; margin-top: 1em">Each GPIO can
have the following Parameters: <br>
(bit r/w) is_output</p>

<p style="margin-left:22%;">If set to 0, the GPIO is an
input. The IO pin is put in a high-impedance state (weakly
pulled high), to be driven by other devices. The logic value
on the IO pin is available in the &quot;in&quot; and
&quot;in_not&quot; HAL pins. Writes to the &quot;out&quot;
HAL pin have no effect. If this parameter is set to 1, the
GPIO is an output; its behavior then depends on the
&quot;is_opendrain&quot; parameter. Only full GPIO pins have
this parameter.</p>

<p style="margin-left:11%;">(bit r/w) is_opendrain</p>

<p style="margin-left:22%;">This parameter only has an
effect if the &quot;is_output&quot; parameter is true. If
this parameter is false, the GPIO behaves as a normal output
pin: the IO pin on the connector is driven to the value
specified by the &quot;out&quot; HAL pin (possibly
inverted), and the value of the &quot;in&quot; and
&quot;in_not&quot; HAL pins is undefined. If this parameter
is true, the GPIO behaves as an open-drain pin. Writing 0 to
the &quot;out&quot; HAL pin drives the IO pin low, writing 1
to the &quot;out&quot; HAL pin puts the IO pin in a
high-impedance state. In this high-impedance state the IO
pin floats (weakly pulled high), and other devices can drive
the value; the resulting value on the IO pin is available on
the &quot;in&quot; and &quot;in_not&quot; pins. Only full
GPIO pins and IO pins used as outputs by active module
instances have this parameter.</p>

<p style="margin-left:11%;">(bit r/w) invert_output</p>

<p style="margin-left:22%;">This parameter only has an
effect if the &quot;is_output&quot; parameter is true. If
this parameter is true, the output value of the GPIO will be
the inverse of the value on the &quot;out&quot; HAL pin.
Only full GPIO pins and IO pins used as outputs by active
module instances have this parameter.</p>

<p style="margin-left:11%; margin-top: 1em">When a physical
I/O pin is used by a special function, the related
<b>is_output</b>, and <b>is_opendrain</b> HAL parameters are
aliased to the special function. For instance, if gpio 1 is
taken over by pwmgen 0&rsquo;s first output, then aliases
like <b>hm2_7i92.0.pwmgen.00.out0.invert_output</b>
(referring to <b>hm2_7i92.0.gpio.001.invert_output</b>) will
be automatically created. When more than one GPIO is
connected to the same special function, an extra .#. is
inserted so that the settings for each related GPIO can be
set separately. For example, for the firmware
SV12IM_2X7I48_72, the alias
<b>hm2_5i20.0.pwmgen.00.0.enable.invert_output</b>
(referring to <b>hm2_5i20.0.gpio.000.invert_output</b>) and
<b>hm2_5i20.0.pwmgen.00.1.enable.invert_output</b>
(referring to <b>hm2_5i20.0.gpio.023.invert_output</b>) are
both created.</p>

<h2>inm and inmux
<a name="inm and inmux"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">inm/inmuxs are
input debouncing modules that support hardware digital
filtering of input pins. In addition to the input filtering
function, the inm/inmux modules support up to 4 simple
quadrature counters for MPG use. The quadrature inputs for
MPG encoders 0 through 3 are inm/inmux pins 0 through 7. MPG
A,B inputs use the filter time constants programmed for
inputs 0..7 Each inm/inmux input pin can have a slow or fast
filter constant. Filter time constants are specified in
units of scan times. inms have names like
&quot;hm2_<i>&lt;BoardType&gt;</i>.<i>&lt;BoardNum&gt;</i>.inm.<i>&lt;Instance&gt;</i>&quot;.
inmuxes have names like
&quot;hm2_<i>&lt;BoardType&gt;</i>.<i>&lt;BoardNum&gt;</i>.inmux.<i>&lt;Instance&gt;</i>&quot;.
&quot;Instance&quot; is a two-digit number that corresponds
to the HostMot2 inm or inmux instance number. There are
&rsquo;num_inms&rsquo; or numx_inmuxs&quot; instances,
starting with 00.</p>

<p style="margin-left:11%; margin-top: 1em">Each instance
reads between 8 and 32 input pins. inm and inmux are
identical except for pin names and the physical
interface</p>

<p style="margin-left:11%; margin-top: 1em">Pins: <br>
(bit out) input and input-not</p>

<p style="margin-left:22%;">true and inverted filtered
input states.</p>

<p style="margin-left:11%;">(bit out) raw-input and
raw-input-not</p>

<p style="margin-left:22%;">true and inverted unfiltered
input states.</p>

<p style="margin-left:11%;">(bit in) input-slow</p>

<p style="margin-left:22%;">If true, selects the long time
constant filter for the corresponding input bit, if false
the short time constant is used.</p>

<p style="margin-left:11%;">(s32 out)
enc0-count,enc1-count,enc2-count,enc3-count</p>

<p style="margin-left:22%;">MPG counters 0 through 3.</p>

<p style="margin-left:11%; margin-top: 1em">Parameters:
<br>
(u32 in) scan_rate</p>

<p style="margin-left:22%;">This sets the input scan rate
in Hz. Default scan rate is 20 KHz (50 uS scan period).</p>

<p style="margin-left:11%;">(u32 in) fast_scans</p>

<p style="margin-left:22%;">This sets the fast time
constant for all input pins. This is the time constant used
when the input-slow pin for the corresponding input is
false. The range is 0 to 63 scan periods and the default
value is 5 = 250 uS at the default 20 Khz scan_rate.</p>

<p style="margin-left:11%;">(u32 in) slow_scans</p>

<p style="margin-left:22%;">This sets the slow time
constant for all input pins. This is the time constant used
when the input-slow pin for the corresponding input is true.
The range is 0 to 1023 scan periods and the default value is
500 = 25 mS at the default 20 Khz scan_rate.</p>

<p style="margin-left:11%;">(bit in) enc0_4xmode,
enc1_4xmode, enc2_4xmode, and enc3_4xmode</p>

<p style="margin-left:22%;">These set the MPG encoder
operating modes to 4X when true and 1X when false.</p>

<p style="margin-left:11%;">(u32 out) scan_width</p>

<p style="margin-left:22%;">This read only parameter
specifies the number of inputs scanned by the module.</p>

<h2>led
<a name="led"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Creates HAL
pins for the LEDs on the FPGA board.</p>

<p style="margin-left:11%; margin-top: 1em">Pins: <br>
(bit in) CR&lt;NN&gt;</p>

<p style="margin-left:22%;">The pins are numbered from CR01
upwards with the name corresponding to the PCB silkscreen.
Setting the bit to &quot;true&quot; or 1 lights the LED.</p>

<h2>Solid State Relay
<a name="Solid State Relay"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">SSRs have names
like
&quot;hm2_<i>&lt;BoardType&gt;</i>.<i>&lt;BoardNum&gt;</i>.ssr.<i>&lt;Instance&gt;</i>&quot;.
&quot;Instance&quot; is a two-digit number that corresponds
to the HostMot2 SSR instance number. There are
&rsquo;num_ssrs&rsquo; instances, starting with 00.</p>

<p style="margin-left:11%; margin-top: 1em">Each instance
has a rate control pin and between 1 and 32 output pins.</p>

<p style="margin-left:11%; margin-top: 1em">Pins: <br>
(u32 in) rate</p>

<p style="margin-left:22%;">Set the internal frequency of
the SSR instance, in Hz (approximate). The valid range is 25
kHz to 25 MHz. Values below the minimum will use the
minimum, and values above the max will use the max. 1 MHz is
a typical value, and appropriate for all Mesa cards, and is
the default. Set to 0 to disable this SSR instance.</p>

<p style="margin-left:11%;">(bit in) out-NN</p>

<p style="margin-left:22%;">The state of this SSR
instance&rsquo;s NNth output. Set to 0 to make the output
pins act like an open switch (no connection), set to 1 to
make them act like a closed switch.</p>

<p style="margin-left:11%;">(bit in) invert-NN</p>

<p style="margin-left:22%;">Inverts the state of this SSR
instance&rsquo;s NNth output, defaults to 0. When invert-NN
is set to 1, SSR output NN is closed when the out-NN pin is
0 and open when the out-NN pin is 1</p>

<h2>OutM Simple output module
<a name="OutM Simple output module"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">OutMs have
names like
&quot;hm2_<i>&lt;BoardType&gt;</i>.<i>&lt;BoardNum&gt;</i>.OutM.<i>&lt;Instance&gt;</i>&quot;.
&quot;Instance&quot; is a two-digit number that corresponds
to the HostMot2 OutM instance number. There are
&rsquo;num_outms&rsquo; instances, starting with 00.</p>

<p style="margin-left:11%; margin-top: 1em">Each instance
has between 1 and 32 output pins.</p>

<p style="margin-left:11%; margin-top: 1em">Pins: <br>
(bit in) out-NN</p>

<p style="margin-left:22%;">The sets the state of this OutM
instance&rsquo;s NNth output. Normally the output pin
follows the state of this pin but may be inverted by the
invert-nn hal pin</p>

<p style="margin-left:11%;">(bit in) invert-NN</p>

<p style="margin-left:22%;">Inverts the state of the this
OutM instance&rsquo;s NNth output, defaults to 0. When
invert-NN is set to 1, OutM output NN is high when the
out-NN pin is 0 and low when the out-NN pin is 1</p>

<h2>xy2mod
<a name="xy2mod"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The xy2mod is a
xy2-100 galvanometer interface. It supports 16 and 18 bit
data modes and includes interpolation to provide position
updates between servo thread invocations.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="7%">


<p>Pins:</p></td>
<td width="82%">
</td></tr>
</table>

<p style="margin-left:11%;">(float in) posx_cmd,
posy_cmd</p>

<p style="margin-left:22%;">X and Y position commands. Full
scale is +-posn_scale default full scale (set by posx_scale
and posy_scale) is +- 1</p>

<p style="margin-left:11%;">(float out) posx_fb,
posy_fb</p>

<p style="margin-left:22%;">X and Y position feedback. Full
scale is +-posN_scale default full scale is +- 1. This is
feedback from the interpolator not the galvanometer.</p>

<p style="margin-left:11%;">(float in) velx_cmd,
vely_cmd</p>

<p style="margin-left:22%;">X and Y velocity commands in
units of fullscale_position/second</p>

<p style="margin-left:11%;">(float out) velx_fb,
vely_fb</p>

<p style="margin-left:22%;">X and Y velocity feedback in
units of fullscale_position/second</p>

<p style="margin-left:11%;">(float in) accx_cmd,
accy_cmd</p>

<p style="margin-left:22%;">X and Y acceleration commands
in units of fullscale_position/second^2</p>

<p style="margin-left:11%;">(float in) posx_scale,
posy_scale</p>

<p style="margin-left:22%;">This sets the full scale range
of the position command and feedback default is +- 1.0</p>

<p style="margin-left:11%;">(bit in) enable</p>

<p style="margin-left:22%;">when false, output data is 0,
all interpolator values are set to 0 and overflow flags are
cleared. Must be true for normal operation.</p>

<p style="margin-left:11%;">(u32 in) controlx, controly</p>

<p style="margin-left:22%;">These set the galavanometer
control bits. There 3 bits per channel in 16 bit mode but
just 1 control bit in 18 bit mode, so values from 0..7 are
valid in 16 bit mode but only 0 and 4 are valid in 18 bit
mode</p>

<p style="margin-left:11%;">(u32 in) commandx, commandy</p>

<p style="margin-left:22%;">These set the raw 16 bit data
sent to the galvanometer in command mode</p>

<p style="margin-left:11%;">(bit in) commandmodex,
commandmodey</p>

<p style="margin-left:22%;">When set, these enable the
command mode where 16 bit command data is sent to the
galvanometer</p>

<p style="margin-left:11%;">(bit in) 18bitmodex,
18bitmodey</p>

<p style="margin-left:22%;">When true, these enable the 18
bit data mode for the respective channel</p>

<p style="margin-left:11%;">(bit out) posx-overflow,
posy-overflow</p>

<p style="margin-left:22%;">When true, these indicate an
attempted position move beyond the full scale value</p>

<p style="margin-left:11%;">(bit out) velx-overflow,
vely-overflow</p>

<p style="margin-left:22%;">When true, these indicate an
attempted velocity update move beyond the full scale
value</p>

<p style="margin-left:11%;">(u32 out) status</p>

<p style="margin-left:22%;">Raw 16 bit return status from
galavanometer.</p>

<p style="margin-left:11%;">Parameters: <br>
(s32 in) read-timer-number</p>

<p style="margin-left:22%;">Selects the DPLL timer number
for pre-read sampling of the position and velocity
registers. If set to -1, pre-read sampling is disabled.</p>

<p style="margin-left:11%;">(s32 in) write-timer-number</p>

<p style="margin-left:22%;">Selects the DPLL timer number
for post write update of the position and velocity
registers. If set to -1, post write update is disabled.</p>

<h2>Watchdog
<a name="Watchdog"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The HostMot2
firmware may include a watchdog Module; if it does, the
hostmot2 driver will use it. The HAL representation of the
watchdog is named
&quot;hm2_<b>&lt;BoardType&gt;</b>.<b>&lt;BoardNum&gt;</b>.watchdog&quot;.</p>

<p style="margin-left:11%; margin-top: 1em">The watchdog
starts out asleep and inactive. Once you access the board
the first time by running the hm2 write() HAL function (see
below), the watchdog wakes up. From them on it must be
petted periodically or it will bite. Pet the watchdog by
running the hm2 write() HAL function.</p>

<p style="margin-left:11%; margin-top: 1em">When the
watchdog bites, all the board&rsquo;s I/O pins are
disconnected from their Module instances and become
high-impedance inputs (pulled high), and all communication
with the board stops. The state of the HostMot2 firwmare
modules is not disturbed (except for the configuration of
the IO Pins). Encoder instances keep counting quadrature
pulses, and pwm- and step-generators keep generating signals
(which are *not* relayed to the motors, because the IO Pins
have become inputs).</p>

<p style="margin-left:11%; margin-top: 1em">Resetting the
watchdog (by clearing the has_bit pin, see below) resumes
communication and resets the I/O pins to the configuration
chosen at load-time.</p>

<p style="margin-left:11%; margin-top: 1em">If the firmware
includes a watchdog, the following HAL objects will be
exported:</p>

<p style="margin-left:11%; margin-top: 1em">Pins: <br>
(bit in/out) has_bit</p>

<p style="margin-left:22%;">True if the watchdog has bit,
False if the watchdog has not bit. If the watchdog has bit
and the has_bit bit is True, the user can reset it to False
to resume operation.</p>


<p style="margin-left:22%; margin-top: 1em">Parameters:</p>

<p style="margin-left:11%;">(u32 read/write) timeout_ns</p>

<p style="margin-left:22%;">Watchdog timeout, in
nanoseconds. This is initialized to 5,000,000 (5
milliseconds) at module load time. If more than this amount
of time passes between calls to the hm2 write() function,
the watchdog will bite.</p>

<h2>Raw Mode
<a name="Raw Mode"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">If the
&quot;enable_raw&quot; config keyword is specified, some
extra debugging pins are made available in HAL. The raw mode
HAL pin names begin with
&quot;hm2_<i>&lt;BoardType&gt;</i>.<i>&lt;BoardNum&gt;</i>.raw&quot;.</p>

<p style="margin-left:11%; margin-top: 1em">With Raw mode
enabled, a user may peek and poke the firmware from HAL, and
may dump the internal state of the hostmot2 driver to the
syslog.</p>

<p style="margin-left:11%; margin-top: 1em">Pins: <br>
(u32 in) read_address</p>

<p style="margin-left:22%;">The bottom 16 bits of this is
used as the address to read from.</p>

<p style="margin-left:11%;">(u32 out) read_data</p>

<p style="margin-left:22%;">Each time the hm2_read()
function is called, this pin is updated with the value at
.read_address.</p>

<p style="margin-left:11%;">(u32 in) write_address</p>

<p style="margin-left:22%;">The bottom 16 bits of this is
used as the address to write to.</p>

<p style="margin-left:11%;">(u32 in) write_data</p>

<p style="margin-left:22%;">This is the value to write to
.write_address.</p>

<p style="margin-left:11%;">(bit in) write_strobe</p>

<p style="margin-left:22%;">Each time the hm2_write()
function is called, this pin is examined. If it is True,
then value in .write_data is written to the address in
.write_address, and .write_strobe is set back to False.</p>

<p style="margin-left:11%;">(bit in/out) dump_state</p>

<p style="margin-left:22%;">This pin is normally False. If
it gets set to True the hostmot2 driver will write its
representation of the board&rsquo;s internal state to the
syslog, and set the pin back to False.</p>

<h2>Setting up Smart Serial devices
<a name="Setting up Smart Serial devices"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">See man
setsserial for the current way to set smart-serial eeprom
parameters.</p>

<h2>FUNCTIONS
<a name="FUNCTIONS"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>hm2_</b><i>&lt;BoardType&gt;</i><b>.</b><i>&lt;BoardNum&gt;</i><b>.read-request</b></p>

<p style="margin-left:22%;">On boards with long turn around
time for reads (at the time of writing, this applies only to
ethernet boards), this function sends a read request. When
multiple boards are used, this can reduce the servo thread
execution time. In this case, the appropriate thread order
would be <br>
addf hm2_7i80.0.read-request <br>
addf hm2_7i80.1.read-request <br>
addf hm2_7i80.0.read <br>
addf hm2_7i80.1.read <br>
which causes the read request to be sent to board 1 before
waiting for the response to the read request to arrive from
board 0.</p>


<p style="margin-left:11%;"><b>hm2_</b><i>&lt;BoardType&gt;</i><b>.</b><i>&lt;BoardNum&gt;</i><b>.read</b></p>

<p style="margin-left:22%;">This reads the encoder
counters, stepgen feedbacks, and GPIO input pins from the
FPGA.</p>


<p style="margin-left:11%;"><b>hm2_</b><i>&lt;BoardType&gt;</i><b>.</b><i>&lt;BoardNum&gt;</i><b>.write</b></p>

<p style="margin-left:22%;">This updates the PWM duty
cycles, stepgen rates, and GPIO outputs on the FPGA. Any
changes to configuration pins such as stepgen timing, GPIO
inversions, etc, are also effected by this function.</p>


<p style="margin-left:11%;"><b>hm2_</b><i>&lt;BoardType&gt;</i><b>.</b><i>&lt;BoardNum&gt;</i><b>.read_gpio</b></p>

<p style="margin-left:22%;">Read the GPIO input pins. Note
that the effect of this function is a subset of the effect
of the .read() function described above. Normally only
.read() is used. The only reason to call this function is if
you want to do GPIO things in a faster-than-servo thread.
(This function is not available on the 7i43 due to
limitations of the EPP bus.)</p>


<p style="margin-left:11%;"><b>hm2_</b><i>&lt;BoardType&gt;</i><b>.</b><i>&lt;BoardNum&gt;</i><b>.write_gpio</b></p>

<p style="margin-left:22%;">Write the GPIO control
registers and output pins. Note that the effect of this
function is a subset of the effect of the .write() function
described above. Normally only .write() is used. The only
reason to call this function is if you want to do GPIO
things in a faster-than-servo thread. (This function is not
available on the 7i43 due to limitations of the EPP
bus.)</p>


<p style="margin-left:11%;"><b>hm2_</b><i>&lt;BoardType&gt;</i><b>.</b><i>&lt;BoardNum&gt;</i><b>.trigger-encoders</b></p>

<p style="margin-left:22%;">This function will only appear
if the firmware contains a BiSS, Fanuc or SSI encoder module
and if the firmare does not contain a hm2dpll module (qv) or
if the modparam contains num_dplls=0. This function should
be inserted first in the thread so that the encoder data is
ready when the main <b>hm2_XXXX.NN.read</b> function runs.
An error message will be printed if the encoder read is not
finished in time. It may be possible to avoid this by
increasing the data rate. If the problem persists and if
&quot;stale&quot; data is acceptable then the function may
be placed later in the thread, allowing a full servo cycle
for the data to be transferred from the devices. If
available it is better to use the synchronous hm2dpll
triggering function.</p>

<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">hm2_pci(9) <br>
hm2_eth(9) <br>
hm2_spi(9) <br>
hm2_rpspi(9) <br>
hm2_7i43(9) <br>
hm2_7i90(9)</p>

<p style="margin-left:11%; margin-top: 1em">Mesa&rsquo;s
documentation for the Anything I/O boards, at
&lt;http://www.mesanet.com&gt;</p>

<h2>LICENSE
<a name="LICENSE"></a>
</h2>

 
<p style="margin-left:11%; margin-top: 1em">GPL</p>
<hr>
</body>
</html>
