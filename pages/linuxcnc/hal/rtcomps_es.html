<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
    "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="es">
<head>
<meta http-equiv="Content-Type" content="application/xhtml+xml; charset=UTF-8" />
<meta name="generator" content="AsciiDoc 8.6.10" />
<title>Descripciones de Componentes HAL</title>
<link rel="stylesheet" href="..//asciidoc.css" type="text/css" />


<link rel="stylesheet" href="..//linuxcnc.css" type="text/css" />
<script type="text/javascript" src="..//asciidoc.js"></script>
<script type="text/javascript">
/*<![CDATA[*/
asciidoc.install(2);
/*]]>*/
</script>
</head>
<body class="book">
<div id="header">
<h1>Descripciones de Componentes HAL</h1>
<div id="toc">
  <div id="toctitle">Tabla de contenidos</div>
  <noscript><p><b>JavaScript must be enabled in your browser to display the table of contents.</b></p></noscript>
</div>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div class="paragraph" id="cha:realtime-components"><p><a id="sec:stepgen"></a> </p></div>
</div>
</div>
<div class="sect1">
<h2 id="_stepgen">1. Stepgen</h2>
<div class="sectionbody">
<div class="paragraph"><p>Este componente proporciona generación de pulsos de paso, basada en software, en
respuesta a comandos de posición o velocidad. En el modo posición tiene
un bucle de posición preajustado, por lo que no se requiere sintonización PID. En
modo velocidad, maneja un motor a la velocidad ordenada, manteniendo los
límites de velocidad y aceleración. Es un componente en tiempo real solamente, y
dependiendo de la velocidad de la CPU, etc, es capaz de velocidades de paso máximas de entre 10 kHz
a 50kHz. El diagrama de bloques del generador de pulsos de pasos muestra un diagrama
con tres bloques; cada uno es un generador de pulsos de paso. El primer diagrama es para
pasos tipo <em>0</em>, (paso y dirección). El segundo es para el tipo de paso <em>1</em>
(arriba/abajo, o pseudo-PWM), y el tercero es para los tipos de paso 2 a 14
(varios patrones de pasos). Los dos primeros diagramas muestran el modo de control de posición
y el tercero muestra el modo de velocidad. El modo de control y tipo de paso
se configuran de forma independiente y se puede seleccionar cualquier combinación.</p></div>
<div class="paragraph"><p></p></div>
<div class="imageblock" style="text-align:center;">
<div class="content">
<img src="images/stepgen-block-diag.png" alt="images/stepgen-block-diag.png" />
</div>
<div class="title">Figura 1. Diagramas de bloques del generador de pulsos, modo posición.</div>
</div>
<div class="listingblock">
<div class="title">Instalación</div>
<div class="content">
<pre><code>halcmd: loadrt stepgen step_type=&lt;type-array&gt; [ctrl_type=&lt;ctrl_array&gt;]</code></pre>
</div></div>
<div class="paragraph"><p><em>&lt;type-array&gt;</em> es una serie de enteros decimales separados por comas. Cada
número carga un generador de pulsos de paso; el valor del número
determina el tipo de stepping. <em>ctrl_type</em> es opcional; si se omite, todos los generadores de paso
serán modo posición. <em>&lt;ctrl_array&gt;</em> es una serie de caracteres <em>p</em> o <em>v</em>,
separados por comas, para especificar modo posición o modo velocidad.</p></div>
<div class="paragraph"><p>Por ejemplo:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>halcmd: loadrt stepgen step_type=0,0,2 ctrl_type=p,p,v</code></pre>
</div></div>
<div class="paragraph"><p>instalará tres generadores de pasos. Los dos primeros usan el tipo de paso <em>0</em>
(paso y dirección) y se ejecutan en modo posición. El tercero usa el tipo de paso
<em>2</em> (cuadratura) y se ejecuta en modo velocidad. El valor predeterminado para
<em>&lt;type-array&gt;</em> es <em>0,0,0</em> que instalará tres generadores de tipo <em>0</em>
(paso/dir). El maximo número de generadores de pasos es 8 (definido en MAX_CHAN en stepgen.c).
Cada generador es independiente, pero todos son actualizados por la(s) misma(s)
función(es) al mismo tiempo. En las siguientes descripciones, <em>&lt;chan&gt;</em>
es el número de un generador específico. El primer generador es el número 0.</p></div>
<div class="listingblock">
<div class="title">Eliminacion</div>
<div class="content">
<pre><code>halcmd: unloadrt stepgen</code></pre>
</div></div>
<div class="paragraph"><div class="title">Pines</div><p>Cada generador de pulsos de paso tendrá varios de estos pines, dependiendo
del tipo de paso y el tipo de control seleccionado:</p></div>
<div class="ulist"><ul>
<li>
<p>
<em>(float) stepgen.&lt;chan&gt;.position-cmd</em> - Posición deseada del motor, en
   unidades de posición (para modo posición solamente).
</p>
</li>
<li>
<p>
<em>(float) stepgen.&lt;chan&gt;.velocity-cmd</em> - Velocidad deseada del motor, en
   unidades de posición por segundo (para modo velocidad solamente).
</p>
</li>
<li>
<p>
<em>(s32) stepgen.&lt;chan&gt;.counts</em> - Posición de retroalimentación en conteos,
   actualizado por <em>capture_position()</em>.
</p>
</li>
<li>
<p>
<em>(float) stepgen.&lt;chan&gt;.position-fb</em> - Posición de retroalimentación en
   unidades de posición, actualizadas por <em>capture_position()</em>.
</p>
</li>
<li>
<p>
<em>(bit) stepgen.&lt;chan&gt;.enable</em> - Habilita la salida de pasos. Cuando es falso,
   no se generan pasos
</p>
</li>
<li>
<p>
<em>(bit) stepgen.&lt;chan&gt;.step</em> - Salida de pulso de pasos (pasos tipo 0 solamente).
</p>
</li>
<li>
<p>
<em>(bit) stepgen.&lt;chan&gt;.dir</em> - Salida de pulso de dirección (pasos tipo 0 solamente).
</p>
</li>
<li>
<p>
<em>(bit) stepgen.&lt;chan&gt;.up</em> - Salida UP pseudo-PWM (pasos tipo 1 solamente).
</p>
</li>
<li>
<p>
<em>(bit) stepgen.&lt;chan&gt;.down</em> - Salida DOWN pseudo-PWM (paso tipo 1 solamente).
</p>
</li>
<li>
<p>
<em>(bit) stepgen.&lt;chan&gt;.phase-A</em> - Salida de fase A (tipos de paso 2-14 solamente).
</p>
</li>
<li>
<p>
<em>(bit) stepgen.&lt;chan&gt;.phase-B</em> - Salida de fase B (tipos de paso 2-14 solamente).
</p>
</li>
<li>
<p>
<em>(bit) stepgen.&lt;chan&gt;.phase-C</em> - Salida de fase C (tipos de paso 3-14 solamente).
</p>
</li>
<li>
<p>
<em>(bit) stepgen.&lt;chan&gt;.phase-D</em> - Salida de fase D (tipos de paso 5-14 solamente).
</p>
</li>
<li>
<p>
<em>(bit) stepgen.&lt;chan&gt;.phase-E</em> - Salida de fase E (tipos de pasos 11-14 solamente).
</p>
</li>
</ul></div>
<div class="ulist"><div class="title">Parametros<a id="sub:stepgen-parameters"></a></div><ul>
<li>
<p>
<em>(float) stepgen.&lt;chan&gt;.position-scale</em> - Pasos por unidad de posición.
   Este parámetro se usa tanto por la salida como por la retroalimentación.
</p>
</li>
<li>
<p>
<em>(float) stepgen.&lt;chan&gt;.maxvel</em> - Velocidad máxima, en unidades de posición
   por segundo. Si es 0.0, no tiene efecto.
</p>
</li>
<li>
<p>
<em>(float) stepgen.&lt;chan&gt;.maxaccel</em> - Tasa máxima de aceleración/desaceleración, en
   unidades de posicion por segundo al cuadrado. Si es 0.0, no tiene efecto.
</p>
</li>
<li>
<p>
<em>(float) stepgen.&lt;chan&gt;.frequency</em> - Frecuencia actual de pasos, en
   pasos por segundo.
</p>
</li>
<li>
<p>
<em>(float) stepgen.&lt;chan&gt;.steplen</em> - Duración de un pulso de paso (pasos
   tipo 0 y 1) o tiempo mínimo en un estado dado (tipos de pasos 2-14), en nanosegundos.
</p>
</li>
<li>
<p>
<em>(float) stepgen.&lt;chan&gt;.stepspace</em> - Espacio mínimo entre dos
   pulsos de paso (tipos de pasos 0 y 1 solamente), en nanosegundos. Establecer a 0
   para habilitar la función stepgen <em>doublefreq</em>. Para usar <em>doublefreq</em> la
   <a href="parallel-port_es.html#sub:parport-functions">funcion reset parport</a> debe estar habilitada.
</p>
</li>
<li>
<p>
<em>(float) stepgen.&lt;chan&gt;.dirsetup</em> - Tiempo mínimo desde un cambio de dirección
   hasta el comienzo del siguiente pulso de paso (pasos tipo 0 solamente), en nanosegundos.
</p>
</li>
<li>
<p>
<em>(float) stepgen.&lt;chan&gt;.dirhold</em> - Tiempo mínimo desde el final de un
   pulso de paso hasta un cambio de dirección (pasos tipo 0 solamente), en nanosegundos.
</p>
</li>
<li>
<p>
<em>(float) stepgen.&lt;chan&gt;.dirdelay</em> - Minimo tiempo entre cualquier paso a un paso
   en la dirección opuesta (paso tipos 1-14 solamente), en nanosegundos.
</p>
</li>
<li>
<p>
<em>(s32) stepgen.&lt;chan&gt;.rawcounts</em> - conteo de retroalimentacion sin procesar, actualizado
   por <em>make_pulses()</em>.
</p>
</li>
</ul></div>
<div class="paragraph"><p>En el modo posición, los valores de <em>maxvel</em> y <em>maxaccel</em> son utilizados por el
bucle de posición interno para evitar la generación de trenes de pulso de paso que
el motor no pueda seguir. Cuando se establecen valores apropiados para el
motor, incluso un gran cambio instantáneo en la posición ordenada
da como resultado un movimiento trapezoidal suave hacia la nueva ubicación. El algoritmo
funciona midiendo el error de posición y el error de velocidad, y
calculando una aceleración que intentara reducir ambos a cero al
mismo tiempo. Para más detalles, incluido el contenido del cuadro <em>ecuación
de control</em>, consulte el código.</p></div>
<div class="paragraph"><p>En el modo velocidad, <em>maxvel</em> es un límite simple que se aplica a la
velocidad ordenada, y <em>maxaccel</em> se usa para aumentar la frecuencia real
si la velocidad ordenada cambia bruscamente. Como en el modo de posición, unos
valores apropiados para estos parámetros aseguran que el motor pueda seguir el
tren de pulsos generado</p></div>
<div class="paragraph"><div class="title">Pasos tipo 0</div><p>El tipo de pasos 0 es el tipo <em>paso y dirección</em> estándar. Cuando se configura para
pasos tipo 0, hay cuatro parámetros adicionales que determinan el tiempo exacto
de las señales de paso y dirección. En la siguiente figura se muestra
el significado de estos parámetros. Los parámetros están en nanosegundos, pero se redondearán a un número entero
múltiplo del período del hilo que llama a la funcion de stepgen <em>make_pulses()</em>.
Por ejemplo, si se llama a <em>make_pulses()</em> cada 16 us, y la longitud Steplen es 20000 ns, entonces los pulsos de paso
son 2us x 16us = 32us de largo. El valor predeterminado para los cuatro parámetros
es 1 ns, pero el redondeo automático tiene efecto la primera vez que el código
se ejecuta. Como un paso requiere <em>steplen</em> ns en alto y <em>stepspace</em> ns
en bajo, la frecuencia máxima es 1.000.000.000 dividido por
<em>(steplen + stepspace)</em>. Si <em>maxfreq</em> se establece más alto que ese límite, se
bajara automáticamente, y si es cero, permanecerá en cero, pero la frecuencia de salida
podra ser aún limitada</p></div>
<div class="paragraph"><p>Al usar el controlador de puerto paralelo, la frecuencia de pasos se puede duplicar usando
la función <a href="parallel-port_es.html#sub:parport-functions">parport reset</a> junto con la
configuración <em>doublefreq</em> de stepgen.</p></div>
<div class="imageblock" style="text-align:center;">
<div class="content">
<img src="images/stepgen-type0.png" alt="images/stepgen-type0.png" />
</div>
<div class="title">Figura 2. Temporizado de Paso y Dirección</div>
</div>
<div class="paragraph"><div class="title">Pasos Tipo 1</div><p>El tipo de pasos 1 tiene dos salidas, <em>subir</em> y <em>bajar</em>. Los pulsos aparecen en una u
otra, dependiendo de la dirección del movimiento deseada. Cada pulso es <em>steplen</em> ns
de largo, y los pulsos están separados por al menos <em>stepspace</em> ns. La
frecuencia máxima es la misma que para el tipo de pasos 0. Si se establece <em>maxfreq</em>
más alto que ese límite, dicha frecuencia se reducirá. Si <em>maxfreq</em> es cero,
seguirá siendo cero, pero la frecuencia de salida seguirá siendo
limitada.</p></div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<div class="title">Aviso</div>
</td>
<td class="content">No use la función <em>reset parport</em> con los tipos de paso 2 - 14.
Pueden producirse resultados inesperados.</td>
</tr></table>
</div>
<div class="paragraph"><div class="title">Paso tipo 2 - 14</div><p>Los tipos de pasos 2 a 14 están basados ​​en estados y tienen de dos a cinco
salidas. En cada paso, un contador de estado se incrementa o disminuye.
Se muestran patrones de salida de dos-tres fases, cuatro fases y cinco fases
como una función del contador de estado. La frecuencia máxima es
1.000.000.000 divididos por <em>steplen</em>, y como en los otros modos, <em>maxfreq</em>
se reducirá si está por encima del límite.</p></div>
<div class="paragraph"><div class="title">Tipos de pasos de dos y tres fases</div><p></p></div>
<div class="imageblock" style="text-align:center;">
<div class="content">
<img src="images/stepgen-type2-4.png" alt="images/stepgen-type2-4.png" />
</div>
</div>
<div class="paragraph"><div class="title">Tipos de pasos de cuatro fases</div><p></p></div>
<div class="imageblock" style="text-align:center;">
<div class="content">
<img src="images/stepgen-type5-10.png" alt="images/stepgen-type5-10.png" />
</div>
</div>
<div class="paragraph"><div class="title">Fases de paso de cinco fases</div><p></p></div>
<div class="imageblock" style="text-align:center;">
<div class="content">
<img src="images/stepgen-type11-14.png" alt="images/stepgen-type11-14.png" />
</div>
</div>
<div class="paragraph"><div class="title">Funciones</div><p>El componente exporta tres funciones. Cada función actúa en todos
los generadores de impulsos de pasos. No esta soportado ejecutar diferentes generadores en diferentes
hilos.</p></div>
<div class="ulist"><ul>
<li>
<p>
<em>(funct) stepgen.make-pulses</em> - Función de alta velocidad para generar
   y contar pulsos (sin punto flotante).
</p>
</li>
<li>
<p>
<em>(funct) stepgen.update-freq</em> - Función de baja velocidad para conversión de posición
   a velocidad, escala y limitación.
</p>
</li>
<li>
<p>
<em>(funct) stepgen.capture-position</em> - Función de baja velocidad para
   retroalimentación, actualizaciones de latches y escalado de posición.
</p>
</li>
</ul></div>
<div class="paragraph"><p>La función de alta velocidad <em>stepgen.make-pulses</em> debe ejecutarse en un
hilo rápido, de 10 a 50 us dependiendo de las
capacidades de la computadora. El período de ese hilo determina la
 frecuencia de paso máxima, ya que <em>steplen</em>, <em>stepspace</em>, <em>dirsetup</em>,
<em>dirhold</em> y <em>dirdelay</em> se redondean a un múltiplo entero del
periodo del hilo en nanosegundos. Las otras dos funciones se pueden llamar a una tasa mucho más baja.</p></div>
<div class="paragraph"><p><a id="sec:pwmgen"></a> </p></div>
</div>
</div>
<div class="sect1">
<h2 id="_pwmgen">2. PWMgen</h2>
<div class="sectionbody">
<div class="paragraph"><p>Este componente proporciona generación de PWM (modulacion de ancho de pulso) basada en software
y formas de onda PDM (Modulación de Densidad de Pulso). Es un
componente en tiempo real solamente, y dependiendo de la velocidad de la CPU, etc, es capaz de
frecuencias PWM de unos pocos cientos de hercios con una resolución bastante buena, a
quizás 10KHz con resolución limitada.</p></div>
<div class="listingblock">
<div class="title">Instalación</div>
<div class="content">
<pre><code>loadrt pwmgen output_type=&lt;config-array&gt;</code></pre>
</div></div>
<div class="paragraph"><p><em>&lt;config-array&gt;</em> es una serie de enteros decimales separados por comas. Cada
número hace que se cargue un único generador PWM; el valor del número
determina el tipo de salida. El siguiente ejemplo instalará tres generadores PWM.
No hay un valor predeterminado; si no se especifica <em>&lt;config-array&gt;</em>,
no se instalarán generadores PWM. La cantidad máxima de generadores de frecuencia
es 8 (definido en MAX_CHAN en pwmgen.c). Cada generador es independiente,
pero todos son actualizados por la(s) misma(s) función(es) al mismo tiempo. En las siguientes
descripciones, <em>&lt;chan&gt;</em> es el número de un generador específico. El primer
generador es el número 0.</p></div>
<div class="listingblock">
<div class="title">Ejemplo</div>
<div class="content">
<pre><code>loadrt pwmgen output_type=0,1,2</code></pre>
</div></div>
<div class="listingblock">
<div class="title">Eliminacion</div>
<div class="content">
<pre><code>unloadrt pwmgen</code></pre>
</div></div>
<div class="paragraph"><div class="title">Tipos de salida</div><p>El generador PWM admite tres diferentes <em>tipos de salida</em>.</p></div>
<div class="ulist"><ul>
<li>
<p>
<em>Tipo de salida 0</em> - un solo pin de salida PWM. Solo se aceptan comandos positivos;
   los valores negativos se tratan como cero (y se verán afectados por el parámetro
   <em>min-dc</em> si no son cero).
</p>
</li>
<li>
<p>
<em>Tipo de salida 1</em> - pines PWM/PDM y de dirección. Entradas positivas y negativas
   saldran como PWM positivo y negativo. El pin de dirección es FALSO
   para comandos positivos, y VERDADERO para comandos negativos. Si su control
   necesita PWM positivo para CW y CCW, use el componente <a href="components_es.html#sub:abs">abs</a>
   para convertir su señal PWM a un valor positivo cuando se ingrese una entrada negativa.
</p>
</li>
<li>
<p>
<em>Tipo de salida 2</em> - Pines UP y DOWN. Para comandos positivos, la señal PWM
   aparece en la salida up, y la salida down permanece en FALSO. Para comandos negativos
   , la señal PWM aparece en la salida down, y la salida up
   sera FALSO. El tipo de salida 2 es el adecuado para conducir la mayoría de puentes H.
</p>
</li>
</ul></div>
<div class="paragraph"><div class="title">Pines</div><p>Cada generador de PWM tendrá los siguientes pines:</p></div>
<div class="ulist"><ul>
<li>
<p>
<em>(float) pwmgen.&lt;chan&gt;.value</em> - Valor de comando, en unidades arbitrarias.
   Será escalado por el parámetro <em>scale</em> (ver a continuación).
</p>
</li>
<li>
<p>
<em>(bit) pwmgen.&lt;chan&gt;.enable</em> - Activa o desactiva las
   salidas del generador PWM.
</p>
</li>
</ul></div>
<div class="paragraph"><p>Cada generador PWM también tendrá algunos de estos pines, dependiendo del
tipo de salida seleccionado:</p></div>
<div class="ulist"><ul>
<li>
<p>
<em>(bit) pwmgen.&lt;chan&gt;.pwm</em> - Salida PWM (o PDM), (tipos de salida 0
   y 1 solo).
</p>
</li>
<li>
<p>
<em>(bit) pwmgen.&lt;chan&gt;.dir</em> - Salida de dirección (salida tipo 1 solamente).
</p>
</li>
<li>
<p>
<em>(bit) pwmgen.&lt;chan&gt;.up</em> - Salida PWM/PDM para un valor de entrada positivo
   (salida tipo 2 solamente).
</p>
</li>
<li>
<p>
<em>(bit) pwmgen.&lt;chan&gt;.down</em> - Salida PWM/PDM para un valor de entrada negativa
   (salida tipo 2 solamente).
</p>
</li>
</ul></div>
<div class="ulist"><div class="title">Parámetros</div><ul>
<li>
<p>
<em>(float) pwmgen.&lt;chan&gt;.scale</em> - Factor de escala para convertir <em>value</em>
   desde unidades arbitrarias hasta valores de ciclo de trabajo. Por ejemplo, si la escala está configurada en 4000
   y el valor de entrada pasado a pwmgen.&lt;chan&gt;.value es 4000, se tomara el
   100% duty-cycle (siempre activado). Si el valor es 2000, entonces será un 50%
</p>
</li>
<li>
<p>
<em>(float) pwmgen.&lt;chan&gt;.pwm-freq</em> - Frecuencia PWM deseada, en Hz.
   Si es 0.0, genera PDM en lugar de PWM. Si se establece más alto que los límites internos,
   la próxima llamada de <em>update_freq()</em> lo establecerá en el límite interno. Si no es cero,
   y <em>dither</em> es falso, la próxima llamada de <em>update_freq()</em> lo configurará en el
   múltiplo entero más cercano del período de la función <em>make_pulses ()</em>.
</p>
</li>
<li>
<p>
<em>(bit) pwmgen.&lt;chan&gt;.dither-pwm</em> - Si es verdadero, permite el tramado para
   alcanzar una frecuencia promedio PWM o
   ciclos de trabajo que no se pueden obtener con PWM puro. Si es falso, tanto la frecuencia PWM
   y el ciclo de trabajo se redondearán a valores que pueden ser
   logrados exactamente.
</p>
</li>
<li>
<p>
<em>(float) pwmgen.&lt;chan&gt;.min-dc</em> - Ciclo de trabajo mínimo, entre 0.0
   y 1.0 (ciclo de trabajo irá a
   cero cuando está deshabilitado, independientemente de esta configuración).
</p>
</li>
<li>
<p>
<em>(float) pwmgen.&lt;chan&gt;.max-dc</em> - Ciclo de trabajo máximo, entre 0.0
   y 1.0.
</p>
</li>
<li>
<p>
<em>(float) pwmgen.&lt;chan&gt;.curr-dc</em> - Ciclo de trabajo actual - después de toda
   limitación y redondeo (solo lectura).
</p>
</li>
</ul></div>
<div class="paragraph"><div class="title">Funciones</div><p>El componente exporta dos funciones. Cada función actúa en todos los
generadores PWM. No esta soportado ejecutar diferentes generadores en diferentes hilos</p></div>
<div class="ulist"><ul>
<li>
<p>
<em>(funct) pwmgen.make-pulses</em> - Función de alta velocidad para generar formas de onda PWM
  (sin punto flotante). La función de alta velocidad <em>pwmgen.make-pulses</em> debe
  ejecutarse en el hilo base (más rápido), de 10 a 50 us dependiendo de la
  capacidades de la computadora. El período de ese hilo determina la máxima
  frecuencia de la portadora PWM, así como la resolución de las señales PWM o PDM. Si
  el hilo base es 50000 ns, entonces cada 50us el módulo decide si es el momento
  de cambiar el estado de la salida. Con un ciclo de trabajo del 50% y frecuencia PWM de 25Hz
  esto significa que la salida cambia de estado cada (1/25)segundos/50uS*50%
  = 400 iteraciones. Esto también significa que tiene 800 valores posible de ciclo de trabajo (sin dithering)
</p>
</li>
<li>
<p>
<em>(funct) pwmgen.update</em> - Función de baja velocidad para escalar y limitar el valor y
  manejar otros parámetros Esta es la función del módulo que contiene alguna
  matemática más complicada para calcular en cuántos periodos base el resultado
  debe ser alto, y en cuántos debe ser bajo.
</p>
</li>
</ul></div>
<div class="paragraph"><p><a id="sec:encoder"></a> </p></div>
</div>
</div>
<div class="sect1">
<h2 id="_encoder">3. Encoder</h2>
<div class="sectionbody">
<div class="paragraph"><p>Este componente proporciona un conteo, basado en software, de señales de
encoders de cuadratura. Es un componente en tiempo real, y dependiendo de
la velocidad de la CPU, la latencia, etc., es capaz de obtener tasas de conteo máximas desde 10 kHz hasta
quizás unos 50kHz.</p></div>
<div class="paragraph"><p>El hilo base debe tener una velocidad doble a la de de conteo para permitir ruido y
variaciónes de timing. Por ejemplo, si tiene un codificador de 100 impulsos por revolución en el
husillo y sus RPM máximas es 3000, el hilo base máximo debe ser de 25 us.
Un encoder de 100 impulsos por revolución tendrá 400 conteos. La velocidad del eje
de 3000 RPM = 50 RPS (revoluciones por segundo). 400*50 = 20,000 cuentas por
segundo o 50 us entre cuentas.</p></div>
<div class="paragraph"><p>El diagrama de bloques del encoder contador es un diagrama de un canal de encoder.</p></div>
<div class="paragraph"><p></p></div>
<div class="imageblock" style="text-align:center;">
<div class="content">
<img src="images/encoder-block-diag.png" alt="images/encoder-block-diag.png" />
</div>
<div class="title">Figura 3. Diagrama de bloque de contador codificador</div>
</div>
<div class="listingblock">
<div class="title">Instalación</div>
<div class="content">
<pre><code>halcmd: loadrt encoder [num_chan=&lt;counters&gt;]</code></pre>
</div></div>
<div class="paragraph"><p><em>&lt;counters&gt;</em> es la cantidad de contadores de encoder que desea
instalar. Si no se especifica <em>numchan</em>,  serán instalados tres contadores.
El maximo número de contadores es 8 (definido en MAX_CHAN en encoder.c). Cada
contador es independiente, pero todos son actualizados por la(s) misma(s) función(es)
 al mismo tiempo. En las siguientes descripciones, <em>&lt;chan&gt;</em> es el número
de un contador específico. El primer contador es el número 0.</p></div>
<div class="listingblock">
<div class="title">Eliminacion</div>
<div class="content">
<pre><code>halcmd: unloadrt encoder</code></pre>
</div></div>
<div class="ulist"><div class="title">Pines</div><ul>
<li>
<p>
<em>encoder.&lt;chan&gt;.counter-mode</em> (bit, I/O) (predeterminado: FALSE) - Habilita el
   modo contador. Cuando es VERDADERO, el contador cuenta cada flanco ascendente
   de la entrada de la fase A, ignorando el valor en la fase B. Esto es útil para
   contar la salida de un solo canal del sensor (sin cuadratura). Cuando es FALSO,
   cuenta en modo cuadratura.
</p>
</li>
<li>
<p>
<em>encoder.&lt;chan&gt;.counts</em> (s32, salida) - Posición, en conteos del codificador.
</p>
</li>
<li>
<p>
<em>encoder.&lt;chan&gt;.counts-latched</em> (s32, salida) - No se usa en este momento.
</p>
</li>
<li>
<p>
<em>encoder.&lt;chan&gt;.index-enable</em> (bit, I/O) - Cuando es VERDADERO, <em>counts</em> y
   <em>position</em> se resetean a cero en el siguiente flanco ascendente de la Fase Z.
   Al mismo tiempo, <em>index-enable</em> se resetea a cero para indicar que el
   flanco ascendente ha aparecido. El pin es bidireccional. Si
   <em>index-enable</em> es FALSO, el canal de la fase Z del codificador será
   ignorado, y el contador contará normalmente. El controlador del codificador nunca
   pondra <em>index-enable</em> en VERDADERO, pero otros componentes puede hacerlo.
</p>
</li>
<li>
<p>
<em>encoder.&lt;chan&gt;.latch-falling</em> (bit, entrada) (predeterminado: TRUE) - No utilizado
   en este momento.
</p>
</li>
<li>
<p>
<em>encoder.&lt;chan&gt;.latch-input</em> (bit, entrada) (predeterminado: TRUE) - No utilizado
   en este momento.
</p>
</li>
<li>
<p>
<em>encoder.&lt;chan&gt;.latch-rising</em> (bit, entrada) - No se usa en este momento.
</p>
</li>
<li>
<p>
<em>encoder.&lt;chan&gt;.min-speed-estimate</em> (float, entrada) - Determina la
   magnitud de velocidad verdadera mínima a la cual
   la velocidad se estimará como distinta de cero, y <em>position-interpolated</em>
   es interpolada. Las unidades de <em>min-speed-estimate</em> son las mismas que
   unidades de <em>velocity</em>. El factor de escala, en cuentas por unidad de longitud. Ajustar
   este parámetro demasiado bajo hará que tome mucho tiempo el que la velocidad pase a 0 después
   de que los impulsos del encoder han dejado de llegar.
</p>
</li>
<li>
<p>
<em>encoder.&lt;chan&gt;.phase-A</em> (bit, entrada) - Fase A de la señal del codificador en cuadratura.
</p>
</li>
<li>
<p>
<em>encoder.&lt;chan&gt;.phase-B</em> (bit, entrada) - Fase B de la señal del codificador en cuadratura.
</p>
</li>
<li>
<p>
<em>encoder.&lt;chan&gt;.phase-Z</em> (bit, entrada) - Fase Z (pulso de índice) de la señal del codificador en cuadratura.
</p>
</li>
<li>
<p>
<em>encoder.&lt;chan&gt;.position</em> (float, salida) - Posición en unidades escaladas (ver <em>position-scale</em>).
</p>
</li>
<li>
<p>
<em>encoder.&lt;chan&gt;.position-interpolated</em> (float, salida) - Posición en unidades escaladas, interpoladas entre
   cuenta del codificador. La <em>posición interpolada</em> intenta interpolar
   entre cuentas del codificador, basandose ​​en la mayor
   velocidad medida reciente. Solo válido cuando la velocidad es aproximadamente
   constante y superior a <em>min-speed-estimate</em>. No lo use para control de posición, ya que su
   valor es incorrecto a velocidades bajas, durante las inversiones de dirección y durante los cambios de velocidad.
   Sin embargo, permite usar un codificador de pocos impulsos (incluido un impulso por
   revolución) para roscado en el torno, y puede tener
   otros usos también.
</p>
</li>
<li>
<p>
<em>encoder.&lt;chan&gt;.position-latched (float, salida)</em> - No utilizado en este momento.
</p>
</li>
<li>
<p>
<em>encoder.&lt;chan&gt;.position-scale (float, I/O)</em> - Factor de escala, en
   cuentas por unidad de longitud. Por ejemplo, si
   la escala de posición es 500, entonces 1000 conteos del codificador se reportarán
   como una posición de 2.0 unidades.
</p>
</li>
<li>
<p>
<em>encoder.&lt;chan&gt;.rawcounts (s32, entrada)</em> - Conteo sin procesar, determinado por
   la funcion <em>update-counters</em>. Este valor es
   actualizado con más frecuencia que las cuentas y la posición. Tampoco se ve afectado
   por un reinicio o pulso de índice.
</p>
</li>
<li>
<p>
<em>encoder.&lt;chan&gt;.reset</em> (bit, entrada) - Cuando es VERDADERO, fuerza <em>count</em> y
   <em>position</em> a cero de inmediato.
</p>
</li>
<li>
<p>
<em>encoder.&lt;chan&gt;.velocity</em> (float, salida) - Velocidad en unidades escaladas por segundo.
   Se utiliza un algoritmo que reduce en gran medida la cuantificación
   de ruido comparado con una simple diferenciacion de la salida de <em>position</em>. Cuando la magnitud
   de la verdadera velocidad está por debajo de la
   estimación de velocidad mínima, la salida de velocidad es 0.
</p>
</li>
<li>
<p>
<em>encoder.&lt;chan&gt;.x4-mode (bit, I/O) (predeterminado: TRUE)</em> - Habilita el
   modo 4x. Cuando es VERDADERO, el contador cuenta cada borde de
   la forma de onda en cuadratura (cuatro cuentas por ciclo completo). Cuando es falso,
   solo cuenta una vez por ciclo completo. Cuando es FALSO, este parámetro es ignorado.
   El modo 1x es útil para algunos jogwheels.
</p>
</li>
</ul></div>
<div class="ulist"><div class="title">Parámetros</div><ul>
<li>
<p>
<em>encoder.&lt;chan&gt;.capture-position.time (s32, RO)</em>
</p>
</li>
<li>
<p>
<em>encoder.&lt;chan&gt;.capture-position.tmax (s32, RW)</em>
</p>
</li>
<li>
<p>
<em>encoder.&lt;chan&gt;.update-counters.time (s32, RO)</em>
</p>
</li>
<li>
<p>
<em>encoder.&lt;chan&gt;.update-counter.tmax (s32, RW)</em>
</p>
</li>
</ul></div>
<div class="paragraph"><div class="title">Funciones</div><p>El componente exporta dos funciones. Cada función actúa en todos los
contadores de encoder - no esta soportado ejecutar diferentes contadores en diferentes hilos.</p></div>
<div class="ulist"><ul>
<li>
<p>
<em>(funct) encoder.update-counters</em> - Función de alta velocidad para contar
   pulsos (sin punto flotante).
</p>
</li>
<li>
<p>
<em>(funct) encoder.capture-position</em> - Función de baja velocidad para actualizar
   latches y escala de posición.
</p>
</li>
</ul></div>
<div class="paragraph"><p><a id="sec:pid"></a> </p></div>
</div>
</div>
<div class="sect1">
<h2 id="_pid">4. PID</h2>
<div class="sectionbody">
<div class="paragraph"><p>Este componente proporciona control Proporcional/Integral/Derivativo
en bucles. Es un componente en tiempo real solamente. Para simplificar, esta discusión
asume que estamos hablando de bucles de posición, sin embargo este
componente se puede utilizar para implementar otros ciclos de retroalimentación como velocidad,
altura de una antorcha, temperatura, etc. El diagrama de bloque de lazo PID es un
diagrama de bloques de un solo bucle PID.</p></div>
<div class="paragraph"><p><a id="fig:pid-block-diag"></a></p></div>
<div class="imageblock" style="text-align:center;">
<div class="content">
<img src="images/pid-block-diag.png" alt="images/pid-block-diag.png" />
</div>
<div class="title">Figura 4. PID Diagrama de bloque de bucle</div>
</div>
<div class="listingblock">
<div class="title">Instalación</div>
<div class="content">
<pre><code>halcmd: loadrt pid [num_chan=&lt;loops&gt;] [debug=1]</code></pre>
</div></div>
<div class="paragraph"><p><em>&lt;loops&gt;</em> es la cantidad de bucles PID que desea instalar. Si
<em>numchan</em> no se especifica, se instalará un solo bucle. El maximo
número de bucles es 16 (definido por MAX_CHAN en pid.c). Cada bucle es completamente
independiente. En las siguientes descripciones, <em>&lt;loopnum&gt;</em> es el numero de bucle
de un bucle específico. El primer bucle es el número 0.</p></div>
<div class="paragraph"><p>Si se especifica <em>debug=1</em>, el componente exportará algunos
pines que
pueden ser útiles durante la depuración y el ajuste. Por defecto, los pines extra
no se exportan, para ahorrar espacio en la memoria compartida y evitar
abarrotar la lista de pines.</p></div>
<div class="listingblock">
<div class="title">Eliminacion</div>
<div class="content">
<pre><code>halcmd: unloadrt pid</code></pre>
</div></div>
<div class="paragraph"><div class="title">Pines</div><p>Los tres pines más importantes son</p></div>
<div class="ulist"><ul>
<li>
<p>
<em>(float) pid.&lt;loopnum&gt;.command</em> - La posición deseada, que sera
   la comandada por otro componente del sistema.
</p>
</li>
<li>
<p>
<em>(float) pid.&lt;loopnum&gt;.feedback</em> - La posición actual, que sera
   la medida por un dispositivo de retroalimentación tal como un encoder.
</p>
</li>
<li>
<p>
<em>(float) pid.&lt;loopnum&gt;.output</em> - Comando de velocidad que intenta
   pasar de la posición actual a la posición deseada.
</p>
</li>
</ul></div>
<div class="paragraph"><p>Para un bucle de posición, <em>command</em> y <em>feedback</em> están en unidades de posición.
Para un eje lineal, esto podría ser pulgadas, mm, metros o lo que sea
pertinente. Del mismo modo, para un eje angular, podría ser grados, radianes,
etc. Las unidades del pin <em>output</em> representan el cambio necesario para hacer
que la retroalimentación coincida con el comando. Como tal, para un bucle de posición, <em>output</em>
es una velocidad, en pulgadas/seg, mm/seg, grados/seg, etc. Las unidades de tiempo son
siempre en segundos, y las unidades de velocidad coinciden con las unidades de posición. Si
el comando y la retroalimentación están en metros, la salida está en metros por
segundo.</p></div>
<div class="paragraph"><p>Cada bucle tiene dos pines que se utilizan para monitorizar o controlar la
operación general del componente.</p></div>
<div class="ulist"><ul>
<li>
<p>
<em>(float) pid.&lt;loopnum&gt;.error</em> - Igual a <em>.command</em> menos <em>.feedback</em>.
</p>
</li>
<li>
<p>
<em>(bit) pid. &lt;loopnum&gt;.enable</em> - Un bit que habilita el bucle. Si
   <em>.enable</em> es falso, todos los integradores se resetean y la salida es
   obligada a cero. Si <em>.enable</em> es verdadero, el ciclo funciona normalmente.
</p>
</li>
</ul></div>
<div class="paragraph"><p>Pines usados ​​para informar la saturación. La saturación ocurre cuando la salida de
el bloque PID está en su límite máximo o mínimo.</p></div>
<div class="ulist"><ul>
<li>
<p>
<em>(bit) pid.&lt;loopnum&gt;.saturated</em> - Verdadero cuando la salida está saturada.
</p>
</li>
<li>
<p>
<em>(float) pid.&lt;loopnum&gt;.saturated_s</em> - El tiempo que la salida ha sido saturada.
</p>
</li>
<li>
<p>
<em>(s32) pid.&lt;loopnum&gt;.saturated_count</em> - La hora en que la salida ha sido saturada.
</p>
</li>
</ul></div>
<div class="paragraph"><p>Las ganancias PID, los límites y otras características <em>ajustables</em> del ciclo estan
disponible como pines para que puedan ajustarse dinámicamente para obtener más
posibilidades de ajuste avanzadas.</p></div>
<div class="ulist"><ul>
<li>
<p>
<em>(float) pid.&lt;loopnum&gt;.Pgain</em> - Ganancia proporcional
</p>
</li>
<li>
<p>
<em>(float) pid.&lt;loopnum&gt;.Igain</em> - Ganancia integral
</p>
</li>
<li>
<p>
<em>(float) pid.&lt;loopnum&gt;.Dgain</em> - Ganancia derivativa
</p>
</li>
<li>
<p>
<em>(float) pid.&lt;loopnum&gt;.bias</em> - Offset constante en la salida
</p>
</li>
<li>
<p>
<em>(float) pid.&lt;loopnum&gt;.FF0</em> - Zeroth Order feedforward - salida
   proporcional al comando (posición).
</p>
</li>
<li>
<p>
<em>(float) pid.&lt;loopnum&gt;.FF1</em> - First order feedforward - salida
   proporcional a la derivada del comando (velocidad).
</p>
</li>
<li>
<p>
<em>(float) pid.&lt;loopnum&gt;.FF2</em> - Second order feedforward - salida
   proporcional a la 2da derivada
   del comando (aceleración).
</p>
</li>
<li>
<p>
<em>(float) pid.&lt;loopnum&gt;.deadband</em> - Cantidad de error que se ignorará
</p>
</li>
<li>
<p>
<em>(float) pid.&lt;loopnum&gt;.maxerror</em> - Límite de error
</p>
</li>
<li>
<p>
<em>(float) pid.&lt;loopnum&gt;.maxerrorI</em> - Limite en error integrador
</p>
</li>
<li>
<p>
<em>(float) pid.&lt;loopnum&gt;.maxerrorD</em> - Límite de error derivativo
</p>
</li>
<li>
<p>
<em>(float) pid.&lt;loopnum&gt;.maxcmdD</em> - Límite de derivada del comando
</p>
</li>
<li>
<p>
<em>(float) pid.&lt;loopnum&gt;.maxcmdDD</em> - Límite de 2ª derivada del comando
</p>
</li>
<li>
<p>
<em>(float) pid.&lt;loopnum&gt;.maxoutput</em> - Límite en el valor de salida
</p>
</li>
</ul></div>
<div class="paragraph"><p>Si se especificó <em>debug=1</em> cuando el componente se instaló,
se exportarán cuatro pines adicionales:</p></div>
<div class="ulist"><ul>
<li>
<p>
<em>(float) pid.&lt;loopnum&gt;.errorI</em> - Integral de error.
</p>
</li>
<li>
<p>
<em>(float) pid.&lt;loopnum&gt;.errorD</em> - Derivada del error.
</p>
</li>
<li>
<p>
<em>(float) pid.&lt;loopnum&gt;.commandD</em> - Derivada del comando.
</p>
</li>
<li>
<p>
<em>(float) pid.&lt;loopnum&gt;.commandDD</em> - 2da derivada del comando.
</p>
</li>
</ul></div>
<div class="paragraph"><div class="title">Funciones</div><p>El componente exporta una función para cada lazo PID. Esta función
realiza todos los cálculos necesarios para el ciclo. Como cada ciclo tiene
su propia función, los bucles individuales se pueden incluir en diferentes hilos
y ejecutar a diferentes velocidades.</p></div>
<div class="ulist"><ul>
<li>
<p>
<em>(funct) pid.&lt;loopnum&gt;.do_pid_calcs</em> - Realiza todos los cálculos
   para un solo bucle PID.
</p>
</li>
</ul></div>
<div class="paragraph"><p>Si quieres entender el algoritmo exacto utilizado para calcular la
salida del bucle PID, consulte la figura <a href="rtcomps_es.html#fig:pid-block-diag">Diagrama de bloques de bucle PID</a>, los
comentarios al comienzo de <em>emc2/src/hal/components/pid.c</em>, y
por supuesto, el código en sí. Los cálculos del bucle están en la funcion C <em>calc_pid()</em>.</p></div>
<div class="paragraph"><p><a id="sec:simulated-encoder"></a> </p></div>
</div>
</div>
<div class="sect1">
<h2 id="_encoder_simulado">5. Encoder simulado</h2>
<div class="sectionbody">
<div class="paragraph"><p>El encoder simulado es exactamente eso. Produce pulsos en cuadratura
con un pulso de índice, a una velocidad controlada por un pin HAL. Principalmente útil
para pruebas.</p></div>
<div class="listingblock">
<div class="title">Instalación</div>
<div class="content">
<pre><code>halcmd: loadrt sim-encoder num_chan=&lt;número&gt;</code></pre>
</div></div>
<div class="paragraph"><p><em>&lt;número&gt;</em> es la cantidad de codificadores que quiere simular. Si no se
especifica, se instalará un solo encoder simulado. El número máximo es 8 (
definido por MAX_CHAN en sim_encoder.c).</p></div>
<div class="listingblock">
<div class="title">Eliminacion</div>
<div class="content">
<pre><code>halcmd: unloadrt sim-encoder</code></pre>
</div></div>
<div class="ulist"><div class="title">Pines</div><ul>
<li>
<p>
<em>(float) sim-encoder.&lt;chan-num&gt;.speed</em> - El comando de velocidad para el
   eje simulado.
</p>
</li>
<li>
<p>
<em>(bit) sim-encoder.&lt;chan-num&gt;.phase-A</em> - Salida de cuadratura.
</p>
</li>
<li>
<p>
<em>(bit) sim-encoder.&lt;chan-num&gt;.phase-B</em> - Salida de cuadratura.
</p>
</li>
<li>
<p>
<em>(bit) sim-encoder.&lt;chan-num&gt;.phase-Z</em> - Salida de impulsos de índice.
</p>
</li>
</ul></div>
<div class="paragraph"><p>Cuando <em>.speed</em> es positivo, <em>.phase-A</em> precede a <em>.phase-B</em>.</p></div>
<div class="ulist"><div class="title">Parámetros</div><ul>
<li>
<p>
<em>(u32) Sim-encoder.&lt;chan-num&gt;.ppr</em> - Impulsos por revolución.
</p>
</li>
<li>
<p>
<em>(float) Sim-encoder.&lt;chan-num&gt;.scale</em> - Factor de escala para <em>speed</em>.
   El valor predeterminado es 1.0, lo que significa que <em>speed</em> está en revoluciones por segundo.
   Cambie a 60 para RPM, a 360 para
   grados por segundo, a 6.283185 para radianes por segundo, etc.
</p>
</li>
</ul></div>
<div class="paragraph"><p>Tenga en cuenta que los pulsos por revolución no son lo mismo que los recuentos por
revolución. Un pulso es un ciclo de cuadratura completo. En la mayoría de encoder,
los contadores contarán cuatro veces durante un ciclo completo.</p></div>
<div class="paragraph"><div class="title">Funciones</div><p>El componente exporta dos funciones. Cada función afecta a todos
los encoder simulados</p></div>
<div class="ulist"><ul>
<li>
<p>
<em>(funct) sim-encoder.make-pulses</em> - Función de alta velocidad para
   generar impulsos de cuadratura (sin punto flotante).
</p>
</li>
<li>
<p>
<em>(funct) sim-encoder.update-speed</em> - Función de baja velocidad para leer
   <em>speed</em>, escalar y configurar <em>make-pulses</em>.
</p>
</li>
</ul></div>
<div class="paragraph"><p><a id="sec:debounce"></a> </p></div>
</div>
</div>
<div class="sect1">
<h2 id="_debounce">6. Debounce</h2>
<div class="sectionbody">
<div class="paragraph"><p>Debounce es un componente en tiempo real que puede filtrar los rebotes creados
por interruptores de contactos mecánicos. También puede ser útil en otras
aplicaciones donde los pulsos cortos deben ser rechazados.</p></div>
<div class="listingblock">
<div class="title">Instalación</div>
<div class="content">
<pre><code>halcmd: loadrt debounce cfg=&lt;config-string&gt;</code></pre>
</div></div>
<div class="paragraph"><p><em>&lt;config-string&gt;</em> es una serie de enteros decimales separados por comas.
Cada número instala
un grupo de filtros antirrebote idénticos, el número determina cuántos
filtros están en el grupo</p></div>
<div class="paragraph"><p>Por ejemplo:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>halcmd: loadrt debounce cfg=1,4,2</code></pre>
</div></div>
<div class="paragraph"><p>instalará tres grupos de filtros. El grupo 0 contiene un filtro,
el grupo 1 contiene cuatro y el grupo 2 contiene dos filtros. El valor por defecto
valor para <em>&lt;config-string&gt;</em> es "<em>1</em>" que instalará un solo grupo
que contiene un solo filtro. El
número máximo de grupos es 8 (definido por MAX_GROUPS en debounce.c).
La cantidad máxima de filtros en un grupo está limitada solo por el
espacio de memoria compartida. Cada grupo es completamente independiente. Todos los filtros en
un solo grupo son idénticos, y todos son actualizados por la misma
funcion al mismo tiempo. En las siguientes descripciones, <em>&lt;G&gt;</em> es el
número de grupo y <em>&lt;F&gt;</em> es el número de filtro dentro del grupo. El
primer filtro es el grupo 0, filtro 0.</p></div>
<div class="listingblock">
<div class="title">Eliminacion</div>
<div class="content">
<pre><code>halcmd: unloadrt debounce</code></pre>
</div></div>
<div class="paragraph"><div class="title">Pines</div><p>Cada filtro individual tiene dos pines.</p></div>
<div class="ulist"><ul>
<li>
<p>
<em>(bit) debounce.&lt;G&gt;.&lt;F&gt;.in</em> - Entrada del filtro <em>&lt;F&gt;</em> en el grupo <em>&lt;G&gt;</em>.
</p>
</li>
<li>
<p>
<em>(bit) debounce.&lt;G&gt;.&lt;F&gt;.out</em> - Salida del filtro <em>&lt;F&gt;</em> en el grupo <em>&lt;G&gt;</em>.
</p>
</li>
</ul></div>
<div class="paragraph"><div class="title">Parámetros</div><p>Cada grupo de filtros tiene un parámetro <span class="footnote"><br />[Cada filtro individual
también tiene una variable de estado interna. Hay un switch en tiempo de
compilacion que puede exportar esa variable como parámetro. Esta
está destinado a pruebas, y simplemente desperdicia memoria compartida en condiciones normales.]<br /></span>.</p></div>
<div class="ulist"><ul>
<li>
<p>
<em>(s32) debounce.&lt;G&gt;.delay</em> - Retraso del filtro para todos los filtros del grupo <em>&lt;G&gt;</em>.
</p>
</li>
</ul></div>
<div class="paragraph"><p>El retraso del filtro está en unidades de período de hilos. El retraso mínimo es
cero. La salida de un filtro de retardo cero sigue exactamente su entrada:
no filtra nada. A medida que aumenta "delay", son rechazados rebotes mas largos.
Si <em>delay</em> es 4, todos los rebotes menores que o
igual a cuatro períodos de hilo serán rechazados.</p></div>
<div class="paragraph"><div class="title">Funciones</div><p>Cada grupo de filtros tiene una función que actualiza todos los filtros
en ese grupo <em>simultáneamente</em>. Diferentes grupos de filtros pueden ser
actualizado a partir de diferentes hilos en diferentes períodos.</p></div>
<div class="ulist"><ul>
<li>
<p>
<em>(funct) debounce.&lt;G&gt;</em> - Actualiza todos los filtros en el grupo <em>&lt;G&gt;</em>.
</p>
</li>
</ul></div>
<div class="paragraph"><p><a id="sec:siggen"></a> </p></div>
</div>
</div>
<div class="sect1">
<h2 id="_siggen">7. Siggen</h2>
<div class="sectionbody">
<div class="paragraph"><p>Siggen es un componente en tiempo real que genera ondas cuadradas, triángulares y
sinusoidales. Se usa principalmente para pruebas.</p></div>
<div class="listingblock">
<div class="title">Instalación</div>
<div class="content">
<pre><code>halcmd: loadrt siggen [num_chan=&lt;chans&gt;]</code></pre>
</div></div>
<div class="paragraph"><p><em>&lt;chans&gt;</em> es la cantidad de generadores de señal que desea instalar.
Si no se especifica <em>numchan</em>, se instalará un generador de señal.
El maximo número de generadores es 16 (como se define en MAX_CHAN en siggen.c). Cada
 generador es completamente independiente. En las siguientes descripciones,
<em>&lt;chan&gt;</em> es el número de un generador de señal específico (los números
comenzar en 0).</p></div>
<div class="listingblock">
<div class="title">Eliminacion</div>
<div class="content">
<pre><code>halcmd: unloadrt siggen</code></pre>
</div></div>
<div class="paragraph"><div class="title">Pines</div><p>Cada generador tiene cinco pines de salida.</p></div>
<div class="ulist"><ul>
<li>
<p>
<em>(float) siggen.&lt;chan&gt;.sine</em> - Salida de onda sinusoidal.
</p>
</li>
<li>
<p>
<em>(float) siggen.&lt;chan&gt;.cosine</em> - Salida de coseno.
</p>
</li>
<li>
<p>
<em>(float) siggen.&lt;chan&gt;.sawtooth</em> - Salida de diente de sierra.
</p>
</li>
<li>
<p>
<em>(float) siggen.&lt;chan&gt;.triangle</em> - Salida de onda triangular.
</p>
</li>
<li>
<p>
<em>(float) siggen.&lt;chan&gt;.square</em> - Salida de onda cuadrada.
</p>
</li>
</ul></div>
<div class="paragraph"><p>Las cinco salidas tienen la misma frecuencia, amplitud y offset.</p></div>
<div class="paragraph"><p>Además de los pines de salida, hay tres pines de control:</p></div>
<div class="ulist"><ul>
<li>
<p>
<em>(float) siggen.&lt;chan&gt;.frequency</em> - Establece la frecuencia en hercios,
   el valor predeterminado es 1 Hz.
</p>
</li>
<li>
<p>
<em>(float) siggen.&lt;chan&gt;.amplitude</em> - Establece la amplitud máxima de
   formas de onda de salida, por defecto es 1.
</p>
</li>
<li>
<p>
<em>(float) siggen.&lt;chan&gt;.offset</em> - Establece el desplazamiento DC de la salida de
   formas de onda, por defecto es 0.
</p>
</li>
</ul></div>
<div class="paragraph"><p>Por ejemplo, si <em>siggen.0.amplitude</em> es 1.0 y <em>siggen.0.offset</em> es
0.0, las salidas oscilarán de -1.0 a /+1.0. Si <em>siggen.0.amplitude</em>
es 2.5 y <em>siggen.0.offset</em> es 10.0, entonces las salidas oscilarán desde
7.5 a 12.5.</p></div>
<div class="paragraph"><div class="title">Parámetros</div><p>Ninguno. <span class="footnote"><br />[Antes de la versión 2.1, frecuencia, amplitud y desplazamiento
fueron parámetros. Se cambiaron a pines para permitir el control por otros
componentes]<br /></span></p></div>
<div class="ulist"><div class="title">Funciones</div><ul>
<li>
<p>
<em>(funct) siggen.&lt;chan&gt;.update</em> - Calcula nuevos valores para las cinco salidas.
</p>
</li>
</ul></div>
<div class="paragraph"><p><a id="sec:lut5"></a> </p></div>
</div>
</div>
<div class="sect1">
<h2 id="_lut5">8. lut5</h2>
<div class="sectionbody">
<div class="paragraph"><p>El componente lut5 es un componente lógico de 5 entradas basado en una tabla de búsqueda.</p></div>
<div class="ulist"><ul>
<li>
<p>
<em>lut5</em> no requiere un hilo de punto flotante.
</p>
</li>
</ul></div>
<div class="listingblock">
<div class="title">Instalación y uso</div>
<div class="content">
<pre><code>loadrt lut5 [count=N|names=name1[,name2...]]
addf lut5.N servo-thread | base-thread
setp lut5.N.function 0xN</code></pre>
</div></div>
<div class="paragraph"><div class="title">Función de computacion</div><p>Para calcular el número hexadecimal para la función comenzando desde la parte superior
ponga un 1 o 0 para indicar si esa fila sería verdadera o falsa. A continuación, escriba cada
número en la columna de salida comenzando desde arriba y escribiéndolos desde la derecha
a la izquierda. Este será el número binario. Usando una calculadora, ingrese el número binario
y luego conviértalo en hexadecimal; ese será el valor para la función.</p></div>
<div class="tableblock">
<table rules="all"
width="50%"
frame="border"
cellspacing="0" cellpadding="4">
<caption class="title">Tabla 1. Tabla de búsqueda</caption>
<col width="16%" />
<col width="16%" />
<col width="16%" />
<col width="16%" />
<col width="16%" />
<col width="16%" />
<thead>
<tr>
<th align="center" valign="top">Bit 4</th>
<th align="center" valign="top">Bit 3</th>
<th align="center" valign="top">Bit 2</th>
<th align="center" valign="top">Bit 1</th>
<th align="center" valign="top">Bit 0</th>
<th align="center" valign="top">Output</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center" valign="top"><p class="table">0</p></td>
<td align="center" valign="top"><p class="table">0</p></td>
<td align="center" valign="top"><p class="table">0</p></td>
<td align="center" valign="top"><p class="table">0</p></td>
<td align="center" valign="top"><p class="table">0</p></td>
<td align="center" valign="top"><p class="table"></p></td>
</tr>
<tr>
<td align="center" valign="top"><p class="table">0</p></td>
<td align="center" valign="top"><p class="table">0</p></td>
<td align="center" valign="top"><p class="table">0</p></td>
<td align="center" valign="top"><p class="table">0</p></td>
<td align="center" valign="top"><p class="table">1</p></td>
<td align="center" valign="top"><p class="table"></p></td>
</tr>
<tr>
<td align="center" valign="top"><p class="table">0</p></td>
<td align="center" valign="top"><p class="table">0</p></td>
<td align="center" valign="top"><p class="table">0</p></td>
<td align="center" valign="top"><p class="table">1</p></td>
<td align="center" valign="top"><p class="table">0</p></td>
<td align="center" valign="top"><p class="table"></p></td>
</tr>
<tr>
<td align="center" valign="top"><p class="table">0</p></td>
<td align="center" valign="top"><p class="table">0</p></td>
<td align="center" valign="top"><p class="table">0</p></td>
<td align="center" valign="top"><p class="table">1</p></td>
<td align="center" valign="top"><p class="table">1</p></td>
<td align="center" valign="top"><p class="table"></p></td>
</tr>
<tr>
<td align="center" valign="top"><p class="table">0</p></td>
<td align="center" valign="top"><p class="table">0</p></td>
<td align="center" valign="top"><p class="table">1</p></td>
<td align="center" valign="top"><p class="table">0</p></td>
<td align="center" valign="top"><p class="table">0</p></td>
<td align="center" valign="top"><p class="table"></p></td>
</tr>
<tr>
<td align="center" valign="top"><p class="table">0</p></td>
<td align="center" valign="top"><p class="table">0</p></td>
<td align="center" valign="top"><p class="table">1</p></td>
<td align="center" valign="top"><p class="table">0</p></td>
<td align="center" valign="top"><p class="table">1</p></td>
<td align="center" valign="top"><p class="table"></p></td>
</tr>
<tr>
<td align="center" valign="top"><p class="table">0</p></td>
<td align="center" valign="top"><p class="table">0</p></td>
<td align="center" valign="top"><p class="table">1</p></td>
<td align="center" valign="top"><p class="table">1</p></td>
<td align="center" valign="top"><p class="table">0</p></td>
<td align="center" valign="top"><p class="table"></p></td>
</tr>
<tr>
<td align="center" valign="top"><p class="table">0</p></td>
<td align="center" valign="top"><p class="table">0</p></td>
<td align="center" valign="top"><p class="table">1</p></td>
<td align="center" valign="top"><p class="table">1</p></td>
<td align="center" valign="top"><p class="table">1</p></td>
<td align="center" valign="top"><p class="table"></p></td>
</tr>
<tr>
<td align="center" valign="top"><p class="table">0</p></td>
<td align="center" valign="top"><p class="table">1</p></td>
<td align="center" valign="top"><p class="table">0</p></td>
<td align="center" valign="top"><p class="table">0</p></td>
<td align="center" valign="top"><p class="table">0</p></td>
<td align="center" valign="top"><p class="table"></p></td>
</tr>
<tr>
<td align="center" valign="top"><p class="table">0</p></td>
<td align="center" valign="top"><p class="table">1</p></td>
<td align="center" valign="top"><p class="table">0</p></td>
<td align="center" valign="top"><p class="table">0</p></td>
<td align="center" valign="top"><p class="table">1</p></td>
<td align="center" valign="top"><p class="table"></p></td>
</tr>
<tr>
<td align="center" valign="top"><p class="table">0</p></td>
<td align="center" valign="top"><p class="table">1</p></td>
<td align="center" valign="top"><p class="table">0</p></td>
<td align="center" valign="top"><p class="table">1</p></td>
<td align="center" valign="top"><p class="table">0</p></td>
<td align="center" valign="top"><p class="table"></p></td>
</tr>
<tr>
<td align="center" valign="top"><p class="table">0</p></td>
<td align="center" valign="top"><p class="table">1</p></td>
<td align="center" valign="top"><p class="table">0</p></td>
<td align="center" valign="top"><p class="table">1</p></td>
<td align="center" valign="top"><p class="table">1</p></td>
<td align="center" valign="top"><p class="table"></p></td>
</tr>
<tr>
<td align="center" valign="top"><p class="table">0</p></td>
<td align="center" valign="top"><p class="table">1</p></td>
<td align="center" valign="top"><p class="table">1</p></td>
<td align="center" valign="top"><p class="table">0</p></td>
<td align="center" valign="top"><p class="table">0</p></td>
<td align="center" valign="top"><p class="table"></p></td>
</tr>
<tr>
<td align="center" valign="top"><p class="table">0</p></td>
<td align="center" valign="top"><p class="table">1</p></td>
<td align="center" valign="top"><p class="table">1</p></td>
<td align="center" valign="top"><p class="table">0</p></td>
<td align="center" valign="top"><p class="table">1</p></td>
<td align="center" valign="top"><p class="table"></p></td>
</tr>
<tr>
<td align="center" valign="top"><p class="table">0</p></td>
<td align="center" valign="top"><p class="table">1</p></td>
<td align="center" valign="top"><p class="table">1</p></td>
<td align="center" valign="top"><p class="table">1</p></td>
<td align="center" valign="top"><p class="table">0</p></td>
<td align="center" valign="top"><p class="table"></p></td>
</tr>
<tr>
<td align="center" valign="top"><p class="table">0</p></td>
<td align="center" valign="top"><p class="table">1</p></td>
<td align="center" valign="top"><p class="table">1</p></td>
<td align="center" valign="top"><p class="table">1</p></td>
<td align="center" valign="top"><p class="table">1</p></td>
<td align="center" valign="top"><p class="table"></p></td>
</tr>
<tr>
<td align="center" valign="top"><p class="table">1</p></td>
<td align="center" valign="top"><p class="table">0</p></td>
<td align="center" valign="top"><p class="table">0</p></td>
<td align="center" valign="top"><p class="table">0</p></td>
<td align="center" valign="top"><p class="table">0</p></td>
<td align="center" valign="top"><p class="table"></p></td>
</tr>
<tr>
<td align="center" valign="top"><p class="table">1</p></td>
<td align="center" valign="top"><p class="table">0</p></td>
<td align="center" valign="top"><p class="table">0</p></td>
<td align="center" valign="top"><p class="table">0</p></td>
<td align="center" valign="top"><p class="table">1</p></td>
<td align="center" valign="top"><p class="table"></p></td>
</tr>
<tr>
<td align="center" valign="top"><p class="table">1</p></td>
<td align="center" valign="top"><p class="table">0</p></td>
<td align="center" valign="top"><p class="table">0</p></td>
<td align="center" valign="top"><p class="table">1</p></td>
<td align="center" valign="top"><p class="table">0</p></td>
<td align="center" valign="top"><p class="table"></p></td>
</tr>
<tr>
<td align="center" valign="top"><p class="table">1</p></td>
<td align="center" valign="top"><p class="table">0</p></td>
<td align="center" valign="top"><p class="table">0</p></td>
<td align="center" valign="top"><p class="table">1</p></td>
<td align="center" valign="top"><p class="table">1</p></td>
<td align="center" valign="top"><p class="table"></p></td>
</tr>
<tr>
<td align="center" valign="top"><p class="table">1</p></td>
<td align="center" valign="top"><p class="table">0</p></td>
<td align="center" valign="top"><p class="table">1</p></td>
<td align="center" valign="top"><p class="table">0</p></td>
<td align="center" valign="top"><p class="table">0</p></td>
<td align="center" valign="top"><p class="table"></p></td>
</tr>
<tr>
<td align="center" valign="top"><p class="table">1</p></td>
<td align="center" valign="top"><p class="table">0</p></td>
<td align="center" valign="top"><p class="table">1</p></td>
<td align="center" valign="top"><p class="table">0</p></td>
<td align="center" valign="top"><p class="table">1</p></td>
<td align="center" valign="top"><p class="table"></p></td>
</tr>
<tr>
<td align="center" valign="top"><p class="table">1</p></td>
<td align="center" valign="top"><p class="table">0</p></td>
<td align="center" valign="top"><p class="table">1</p></td>
<td align="center" valign="top"><p class="table">1</p></td>
<td align="center" valign="top"><p class="table">0</p></td>
<td align="center" valign="top"><p class="table"></p></td>
</tr>
<tr>
<td align="center" valign="top"><p class="table">1</p></td>
<td align="center" valign="top"><p class="table">0</p></td>
<td align="center" valign="top"><p class="table">1</p></td>
<td align="center" valign="top"><p class="table">1</p></td>
<td align="center" valign="top"><p class="table">1</p></td>
<td align="center" valign="top"><p class="table"></p></td>
</tr>
<tr>
<td align="center" valign="top"><p class="table">1</p></td>
<td align="center" valign="top"><p class="table">1</p></td>
<td align="center" valign="top"><p class="table">0</p></td>
<td align="center" valign="top"><p class="table">0</p></td>
<td align="center" valign="top"><p class="table">0</p></td>
<td align="center" valign="top"><p class="table"></p></td>
</tr>
<tr>
<td align="center" valign="top"><p class="table">1</p></td>
<td align="center" valign="top"><p class="table">1</p></td>
<td align="center" valign="top"><p class="table">0</p></td>
<td align="center" valign="top"><p class="table">0</p></td>
<td align="center" valign="top"><p class="table">1</p></td>
<td align="center" valign="top"><p class="table"></p></td>
</tr>
<tr>
<td align="center" valign="top"><p class="table">1</p></td>
<td align="center" valign="top"><p class="table">1</p></td>
<td align="center" valign="top"><p class="table">0</p></td>
<td align="center" valign="top"><p class="table">1</p></td>
<td align="center" valign="top"><p class="table">0</p></td>
<td align="center" valign="top"><p class="table"></p></td>
</tr>
<tr>
<td align="center" valign="top"><p class="table">1</p></td>
<td align="center" valign="top"><p class="table">1</p></td>
<td align="center" valign="top"><p class="table">0</p></td>
<td align="center" valign="top"><p class="table">1</p></td>
<td align="center" valign="top"><p class="table">1</p></td>
<td align="center" valign="top"><p class="table"></p></td>
</tr>
<tr>
<td align="center" valign="top"><p class="table">1</p></td>
<td align="center" valign="top"><p class="table">1</p></td>
<td align="center" valign="top"><p class="table">1</p></td>
<td align="center" valign="top"><p class="table">0</p></td>
<td align="center" valign="top"><p class="table">0</p></td>
<td align="center" valign="top"><p class="table"></p></td>
</tr>
<tr>
<td align="center" valign="top"><p class="table">1</p></td>
<td align="center" valign="top"><p class="table">1</p></td>
<td align="center" valign="top"><p class="table">1</p></td>
<td align="center" valign="top"><p class="table">0</p></td>
<td align="center" valign="top"><p class="table">1</p></td>
<td align="center" valign="top"><p class="table"></p></td>
</tr>
<tr>
<td align="center" valign="top"><p class="table">1</p></td>
<td align="center" valign="top"><p class="table">1</p></td>
<td align="center" valign="top"><p class="table">1</p></td>
<td align="center" valign="top"><p class="table">1</p></td>
<td align="center" valign="top"><p class="table">0</p></td>
<td align="center" valign="top"><p class="table"></p></td>
</tr>
<tr>
<td align="center" valign="top"><p class="table">1</p></td>
<td align="center" valign="top"><p class="table">1</p></td>
<td align="center" valign="top"><p class="table">1</p></td>
<td align="center" valign="top"><p class="table">1</p></td>
<td align="center" valign="top"><p class="table">1</p></td>
<td align="center" valign="top"><p class="table"></p></td>
</tr>
</tbody>
</table>
</div>
<div class="paragraph"><div class="title">Ejemplo de dos entradas</div><p>En la siguiente tabla, hemos seleccionado el estado de salida para cada línea
que deseamos sea verdad</p></div>
<div class="tableblock">
<table rules="all"
width="50%"
frame="border"
cellspacing="0" cellpadding="4">
<caption class="title">Tabla 2. Tabla de búsqueda</caption>
<col width="16%" />
<col width="16%" />
<col width="16%" />
<col width="16%" />
<col width="16%" />
<col width="16%" />
<thead>
<tr>
<th align="center" valign="top">Bit 4</th>
<th align="center" valign="top">Bit 3</th>
<th align="center" valign="top">Bit 2</th>
<th align="center" valign="top">Bit 1</th>
<th align="center" valign="top">Bit 0</th>
<th align="center" valign="top">Output</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center" valign="top"><p class="table">0</p></td>
<td align="center" valign="top"><p class="table">0</p></td>
<td align="center" valign="top"><p class="table">0</p></td>
<td align="center" valign="top"><p class="table">0</p></td>
<td align="center" valign="top"><p class="table">0</p></td>
<td align="center" valign="top"><p class="table">0</p></td>
</tr>
<tr>
<td align="center" valign="top"><p class="table">0</p></td>
<td align="center" valign="top"><p class="table">0</p></td>
<td align="center" valign="top"><p class="table">0</p></td>
<td align="center" valign="top"><p class="table">0</p></td>
<td align="center" valign="top"><p class="table">1</p></td>
<td align="center" valign="top"><p class="table">1</p></td>
</tr>
<tr>
<td align="center" valign="top"><p class="table">0</p></td>
<td align="center" valign="top"><p class="table">0</p></td>
<td align="center" valign="top"><p class="table">0</p></td>
<td align="center" valign="top"><p class="table">1</p></td>
<td align="center" valign="top"><p class="table">0</p></td>
<td align="center" valign="top"><p class="table">0</p></td>
</tr>
<tr>
<td align="center" valign="top"><p class="table">0</p></td>
<td align="center" valign="top"><p class="table">0</p></td>
<td align="center" valign="top"><p class="table">0</p></td>
<td align="center" valign="top"><p class="table">1</p></td>
<td align="center" valign="top"><p class="table">1</p></td>
<td align="center" valign="top"><p class="table">1</p></td>
</tr>
</tbody>
</table>
</div>
<div class="paragraph"><p>Mirando la columna de salida de nuestro ejemplo queremos que la salida esté en ON
cuando Bit 0 o (Bit 0 y Bit1) están activados y nada más. El número binario es
<em>b1010</em> (gira la salida 90 grados CW). Ingrese este número en la
calculadora luego cambie la pantalla a hexadecimal y el número necesario para
la función es <em>0xa</em>. El prefijo hexadecimal es <em>0x</em>.</p></div>
</div>
</div>
</div>
<div id="footnotes"><hr /></div>
<div id="footer">
<div id="footer-text">
Last updated
 2022-11-24 07:38:35 MST
</div>
</div>
</body>
</html>
